

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyTooling.Graph &mdash; pyTooling 8.8.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=55b73dce" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-reports.089ed2e62f89368aa21ac7591d90c12a.css?v=83177741" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/override.css?v=ddb7e066" />

  
    <link rel="shortcut icon" href="../../_static/icon.png"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=ce2bb500"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
      <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";

const style = document.createElement('style');
style.textContent = `.mermaid-container {
    position: relative !important;
    display: inline-block;
    width: 100%;
}

.mermaid-fullscreen-btn {
    position: absolute !important;
    width: 28px;
    height: 28px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    cursor: pointer;
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    font-size: 14px;
    line-height: 1;
    padding: 0;
    color: #333;
}

.mermaid-fullscreen-btn:hover {
    opacity: 100% !important;
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    transform: scale(1.1);
}

.mermaid-fullscreen-btn.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #e0e0e0;
}

.mermaid-fullscreen-btn.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 3px 10px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal {
    display: none;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw;
    height: 100vh;
    background: rgba(255, 255, 255, 0.98);
    z-index: 9999;
    padding: 20px;
    overflow: auto;
}

.mermaid-fullscreen-modal.dark-theme {
    background: rgba(0, 0, 0, 0.98);
}

.mermaid-fullscreen-modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-fullscreen-content {
    position: relative;
    width: 95vw;
    height: 90vh;
    max-width: 95vw;
    max-height: 90vh;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    overflow: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-fullscreen-content.dark-theme {
    background: #1a1a1a;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
}

.mermaid-fullscreen-content .mermaid {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-fullscreen-content .mermaid svg {
    width: 100%;
    height: auto;
    max-width: 100%;
    max-height: 85vh;
    cursor: grab;
}

.mermaid-fullscreen-close {
    position: fixed !important;
    top: 20px !important;
    right: 20px !important;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    cursor: pointer;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.2s;
    font-size: 24px;
    line-height: 1;
    color: #333;
}

.mermaid-fullscreen-close:hover {
    background: white;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    transform: scale(1.1);
}

.mermaid-fullscreen-close.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #e0e0e0;
}

.mermaid-fullscreen-close.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 6px 16px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal .mermaid-fullscreen-btn {
    display: none !important;
}
`;
document.head.appendChild(style);

// Detect if page has dark background
const isDarkTheme = () => {
    const bgColor = window.getComputedStyle(document.body).backgroundColor;
    const match = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
    }
    return false;
};

const initFullscreen = async () => {
    await mermaid.run();

    const all_mermaids = document.querySelectorAll(".mermaid");
    const mermaids_processed = document.querySelectorAll(".mermaid[data-processed='true']");

    if(all_mermaids.length !== mermaids_processed.length) {
        // Wait for mermaid to process all diagrams
        setTimeout(initFullscreen, 200);
        return;
    }

    const darkTheme = isDarkTheme();

    const modal = document.createElement('div');
    modal.className = 'mermaid-fullscreen-modal' + (darkTheme ? ' dark-theme' : '');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-label', 'Fullscreen diagram viewer');
    modal.innerHTML = `
        <button class="mermaid-fullscreen-close${darkTheme ? ' dark-theme' : ''}" aria-label="Close fullscreen">✕</button>
        <div class="mermaid-fullscreen-content${darkTheme ? ' dark-theme' : ''}"></div>
    `;
    document.body.appendChild(modal);

    const modalContent = modal.querySelector('.mermaid-fullscreen-content');
    const closeBtn = modal.querySelector('.mermaid-fullscreen-close');

    const closeModal = () => {
        modal.classList.remove('active');
        modalContent.innerHTML = '';
        document.body.style.overflow = '';
    };

    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeModal();
        }
    });

    const allButtons = [];

    document.querySelectorAll('.mermaid').forEach((mermaidDiv) => {
        if (mermaidDiv.parentNode.classList.contains('mermaid-container') ||
            mermaidDiv.closest('.mermaid-fullscreen-modal')) {
            return;
        }

        const container = document.createElement('div');
        container.className = 'mermaid-container';
        mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
        container.appendChild(mermaidDiv);

        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'mermaid-fullscreen-btn' + (darkTheme ? ' dark-theme' : '');
        fullscreenBtn.setAttribute('aria-label', 'View diagram in fullscreen');
        fullscreenBtn.textContent = '⛶';

        // Calculate dynamic position based on diagram's margin and padding
        const diagramStyle = window.getComputedStyle(mermaidDiv);
        const marginTop = parseFloat(diagramStyle.marginTop) || 0;
        const marginRight = parseFloat(diagramStyle.marginRight) || 0;
        const paddingTop = parseFloat(diagramStyle.paddingTop) || 0;
        const paddingRight = parseFloat(diagramStyle.paddingRight) || 0;
        fullscreenBtn.style.top = `${marginTop + paddingTop + 4}px`;
        fullscreenBtn.style.right = `${marginRight + paddingRight + 4}px`;

        fullscreenBtn.addEventListener('click', () => {
            const clone = mermaidDiv.cloneNode(true);
            modalContent.innerHTML = '';
            modalContent.appendChild(clone);

            const svg = clone.querySelector('svg');
            if (svg) {
                svg.removeAttribute('width');
                svg.removeAttribute('height');
                svg.style.width = '100%';
                svg.style.height = 'auto';
                svg.style.maxWidth = '100%';
                svg.style.display = 'block';
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        });

        container.appendChild(fullscreenBtn);
        allButtons.push(fullscreenBtn);
    });

    // Update theme classes when theme changes
    const updateTheme = () => {
        const dark = isDarkTheme();
        allButtons.forEach(btn => {
            if (dark) {
                btn.classList.add('dark-theme');
            } else {
                btn.classList.remove('dark-theme');
            }
        });
        if (dark) {
            modal.classList.add('dark-theme');
            modalContent.classList.add('dark-theme');
            closeBtn.classList.add('dark-theme');
        } else {
            modal.classList.remove('dark-theme');
            modalContent.classList.remove('dark-theme');
            closeBtn.classList.remove('dark-theme');
        }
    };

    // Watch for theme changes
    const observer = new MutationObserver(updateTheme);
    observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class', 'style', 'data-theme']
    });
    observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['class', 'style']
    });
};

window.addEventListener("load", initFullscreen);
</script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../News.html">News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation/Updates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Dependency.html">Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tutorials/index.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Attributes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Attributes/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Attributes/ArgParse.html">ArgParse</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">CLI Abstraction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../CLIAbstraction/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CLIAbstraction/Program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CLIAbstraction/Executable.html">Executable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CLIAbstraction/Arguments.html">Arguments</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Common</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Common/index.html">Common Helper Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Common/CallByRef.html">CallByRef</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Common/Licensing.html">Licensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Common/Filesystem.html">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Common/Platform.html">Platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Common/Stopwatch.html">Stopwatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Common/Versioning.html">Versioning</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Configuration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Configuration/index.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Configuration/FileFormats.html">File Formats</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../DataStructures/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DataStructures/LinkedList.html">Doubly Linked List</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DataStructures/Cartesian.html">2D Cartesian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DataStructures/Cartesian.html#struct-cartesian3d">3D Cartesian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DataStructures/Graph.html">Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DataStructures/Path/index.html">Path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DataStructures/StateMachine.html">StateMachine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DataStructures/Tree.html">Tree</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Decorators</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Decorators.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Decorators.html#abstract-methods">Abstract Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Decorators.html#data-access">Data Access</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Decorators.html#documentation">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Decorators.html#performance">Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Decorators.html#miscellaneous">Miscellaneous</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exceptions and Warnings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Exceptions.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Exceptions.html#exception-base-classes">Exception Base Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Exceptions.html#predefined-exceptions">Predefined Exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Warning/index.html">Warnings</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Meta Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../MetaClasses.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MetaClasses.html#extendedtype">ExtendedType</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MetaClasses.html#overloading">Overloading</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Packaging</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Packaging.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Packaging.html#helper-functions">Helper Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Packaging.html#packagedescriptions">PackageDescriptions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Terminal</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Terminal/index.html">Terminal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Terminal/index.html#line">Line</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References and Reports</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../pyTooling/pyTooling.html">Python Class Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unittests/index.html">Unittest Summary Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../coverage/index.html">Code Coverage Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CodeCoverage.html">Code Coverage Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DocCoverage.html">Doc. Coverage Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../typing/index.html">Static Type Check Report ➚</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../License.html">Apache License 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Doc-License.html">Creative Commons Attribution 4.0 International</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../py-modindex.html">Python Module Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../TODO.html">TODOs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyTooling</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyTooling.Graph</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyTooling.Graph</h1><div class="highlight"><pre>
<span></span><span class="c1"># ==================================================================================================================== #</span>
<span class="c1">#             _____           _ _               ____                 _                                                 #</span>
<span class="c1">#  _ __  _   |_   _|__   ___ | (_)_ __   __ _  / ___|_ __ __ _ _ __ | |__                                              #</span>
<span class="c1"># | &#39;_ \| | | || |/ _ \ / _ \| | | &#39;_ \ / _` || |  _| &#39;__/ _` | &#39;_ \| &#39;_ \                                             #</span>
<span class="c1"># | |_) | |_| || | (_) | (_) | | | | | | (_| || |_| | | | (_| | |_) | | | |                                            #</span>
<span class="c1"># | .__/ \__, ||_|\___/ \___/|_|_|_| |_|\__, (_)____|_|  \__,_| .__/|_| |_|                                            #</span>
<span class="c1"># |_|    |___/                          |___/                 |_|                                                      #</span>
<span class="c1"># ==================================================================================================================== #</span>
<span class="c1"># Authors:                                                                                                             #</span>
<span class="c1">#   Patrick Lehmann                                                                                                    #</span>
<span class="c1">#                                                                                                                      #</span>
<span class="c1"># License:                                                                                                             #</span>
<span class="c1"># ==================================================================================================================== #</span>
<span class="c1"># Copyright 2017-2025 Patrick Lehmann - Bötzingen, Germany                                                             #</span>
<span class="c1">#                                                                                                                      #</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);                                                      #</span>
<span class="c1"># you may not use this file except in compliance with the License.                                                     #</span>
<span class="c1"># You may obtain a copy of the License at                                                                              #</span>
<span class="c1">#                                                                                                                      #</span>
<span class="c1">#   http://www.apache.org/licenses/LICENSE-2.0                                                                         #</span>
<span class="c1">#                                                                                                                      #</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software                                                  #</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,                                                    #</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.                                             #</span>
<span class="c1"># See the License for the specific language governing permissions and                                                  #</span>
<span class="c1"># limitations under the License.                                                                                       #</span>
<span class="c1">#                                                                                                                      #</span>
<span class="c1"># SPDX-License-Identifier: Apache-2.0                                                                                  #</span>
<span class="c1"># ==================================================================================================================== #</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A powerful **graph** data structure for Python.</span>

<span class="sd">Graph algorithms using all vertices are provided as methods on the graph instance. Whereas graph algorithms based on a</span>
<span class="sd">starting vertex are provided as methods on a vertex.</span>

<span class="sd">.. admonition:: Example Graph</span>

<span class="sd">	.. mermaid::</span>
<span class="sd">		 :caption: A directed graph with backward-edges denoted by dotted vertex relations.</span>

<span class="sd">		 %%{init: { &quot;flowchart&quot;: { &quot;nodeSpacing&quot;: 15, &quot;rankSpacing&quot;: 30, &quot;curve&quot;: &quot;linear&quot;, &quot;useMaxWidth&quot;: false } } }%%</span>
<span class="sd">		 graph LR</span>
<span class="sd">			 A(A); B(B); C(C); D(D); E(E); F(F) ; G(G); H(H); I(I)</span>

<span class="sd">			 A --&gt; B --&gt; E</span>
<span class="sd">			 G --&gt; F</span>
<span class="sd">			 A --&gt; C --&gt; G --&gt; H --&gt; D</span>
<span class="sd">			 D -.-&gt; A</span>
<span class="sd">			 D &amp; F -.-&gt; B</span>
<span class="sd">			 I ---&gt; E --&gt; F --&gt; D</span>

<span class="sd">			 classDef node fill:#eee,stroke:#777,font-size:smaller;</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w">   </span><span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w">      </span><span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Deque</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span> <span class="k">as</span> <span class="n">Nullable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w">      </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterator</span> <span class="k">as</span> <span class="n">typing_Iterator</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Hashable</span>

<span class="k">try</span><span class="p">:</span>
	<span class="kn">from</span><span class="w"> </span><span class="nn">pyTooling.Decorators</span><span class="w">  </span><span class="kn">import</span> <span class="n">export</span><span class="p">,</span> <span class="n">readonly</span>
	<span class="kn">from</span><span class="w"> </span><span class="nn">pyTooling.MetaClasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">ExtendedType</span>
	<span class="kn">from</span><span class="w"> </span><span class="nn">pyTooling.Exceptions</span><span class="w">  </span><span class="kn">import</span> <span class="n">ToolingException</span>
	<span class="kn">from</span><span class="w"> </span><span class="nn">pyTooling.Common</span><span class="w">      </span><span class="kn">import</span> <span class="n">getFullyQualifiedName</span>
	<span class="kn">from</span><span class="w"> </span><span class="nn">pyTooling.Tree</span><span class="w">        </span><span class="kn">import</span> <span class="n">Node</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">ModuleNotFoundError</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
	<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[pyTooling.Graph] Could not import from &#39;pyTooling.*&#39;!&quot;</span><span class="p">)</span>

	<span class="k">try</span><span class="p">:</span>
		<span class="kn">from</span><span class="w"> </span><span class="nn">Decorators</span><span class="w">          </span><span class="kn">import</span> <span class="n">export</span><span class="p">,</span> <span class="n">readonly</span>
		<span class="kn">from</span><span class="w"> </span><span class="nn">MetaClasses</span><span class="w">         </span><span class="kn">import</span> <span class="n">ExtendedType</span><span class="p">,</span> <span class="n">mixin</span>
		<span class="kn">from</span><span class="w"> </span><span class="nn">Exceptions</span><span class="w">          </span><span class="kn">import</span> <span class="n">ToolingException</span>
		<span class="kn">from</span><span class="w"> </span><span class="nn">Common</span><span class="w">              </span><span class="kn">import</span> <span class="n">getFullyQualifiedName</span>
		<span class="kn">from</span><span class="w"> </span><span class="nn">Tree</span><span class="w">                </span><span class="kn">import</span> <span class="n">Node</span>
	<span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">ModuleNotFoundError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[pyTooling.Graph] Could not import directly!&quot;</span><span class="p">)</span>
		<span class="k">raise</span> <span class="n">ex</span>


<span class="n">DictKeyType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;DictKeyType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for dictionary keys.&quot;&quot;&quot;</span>

<span class="n">DictValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;DictValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for dictionary values.&quot;&quot;&quot;</span>

<span class="n">IDType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;IDType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for an ID.&quot;&quot;&quot;</span>

<span class="n">WeightType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;WeightType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>
<span class="sd">&quot;&quot;&quot;A type variable for a weight.&quot;&quot;&quot;</span>

<span class="n">ValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;ValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a value.&quot;&quot;&quot;</span>

<span class="n">VertexIDType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;VertexIDType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a vertex&#39;s ID.&quot;&quot;&quot;</span>

<span class="n">VertexWeightType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;VertexWeightType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>
<span class="sd">&quot;&quot;&quot;A type variable for a vertex&#39;s weight.&quot;&quot;&quot;</span>

<span class="n">VertexValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;VertexValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a vertex&#39;s value.&quot;&quot;&quot;</span>

<span class="n">VertexDictKeyType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;VertexDictKeyType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a vertex&#39;s dictionary keys.&quot;&quot;&quot;</span>

<span class="n">VertexDictValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;VertexDictValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a vertex&#39;s dictionary values.&quot;&quot;&quot;</span>

<span class="n">EdgeIDType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;EdgeIDType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for an edge&#39;s ID.&quot;&quot;&quot;</span>

<span class="n">EdgeWeightType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;EdgeWeightType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>
<span class="sd">&quot;&quot;&quot;A type variable for an edge&#39;s weight.&quot;&quot;&quot;</span>

<span class="n">EdgeValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;EdgeValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for an edge&#39;s value.&quot;&quot;&quot;</span>

<span class="n">EdgeDictKeyType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;EdgeDictKeyType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for an edge&#39;s dictionary keys.&quot;&quot;&quot;</span>

<span class="n">EdgeDictValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;EdgeDictValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for an edge&#39;s dictionary values.&quot;&quot;&quot;</span>

<span class="n">LinkIDType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;LinkIDType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for an link&#39;s ID.&quot;&quot;&quot;</span>

<span class="n">LinkWeightType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;LinkWeightType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>
<span class="sd">&quot;&quot;&quot;A type variable for an link&#39;s weight.&quot;&quot;&quot;</span>

<span class="n">LinkValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;LinkValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for an link&#39;s value.&quot;&quot;&quot;</span>

<span class="n">LinkDictKeyType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;LinkDictKeyType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for an link&#39;s dictionary keys.&quot;&quot;&quot;</span>

<span class="n">LinkDictValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;LinkDictValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for an link&#39;s dictionary values.&quot;&quot;&quot;</span>

<span class="n">ComponentDictKeyType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;ComponentDictKeyType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a component&#39;s dictionary keys.&quot;&quot;&quot;</span>

<span class="n">ComponentDictValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;ComponentDictValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a component&#39;s dictionary values.&quot;&quot;&quot;</span>

<span class="n">SubgraphDictKeyType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;SubgraphDictKeyType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a component&#39;s dictionary keys.&quot;&quot;&quot;</span>

<span class="n">SubgraphDictValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;SubgraphDictValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a component&#39;s dictionary values.&quot;&quot;&quot;</span>

<span class="n">ViewDictKeyType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;ViewDictKeyType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a component&#39;s dictionary keys.&quot;&quot;&quot;</span>

<span class="n">ViewDictValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;ViewDictValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a component&#39;s dictionary values.&quot;&quot;&quot;</span>

<span class="n">GraphDictKeyType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;GraphDictKeyType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Hashable</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a graph&#39;s dictionary keys.&quot;&quot;&quot;</span>

<span class="n">GraphDictValueType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;GraphDictValueType&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type variable for a graph&#39;s dictionary values.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="GraphException">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.GraphException">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GraphException</span><span class="p">(</span><span class="n">ToolingException</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;Base exception of all exceptions raised by :mod:`pyTooling.Graph`.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="InternalError">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.InternalError">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">InternalError</span><span class="p">(</span><span class="n">GraphException</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	The exception is raised when a data structure corruption is detected.</span>

<span class="sd">	.. danger::</span>

<span class="sd">	   This exception should never be raised.</span>

<span class="sd">	   If so, please create an issue at GitHub so the data structure corruption can be investigated and fixed. |br|</span>
<span class="sd">	   `⇒ Bug Tracker at GitHub &lt;https://github.com/pyTooling/pyTooling/issues&gt;`__</span>
<span class="sd">	&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="NotInSameGraph">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.NotInSameGraph">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NotInSameGraph</span><span class="p">(</span><span class="n">GraphException</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;The exception is raised when creating an edge between two vertices, but these are not in the same graph.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="DuplicateVertexError">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.DuplicateVertexError">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DuplicateVertexError</span><span class="p">(</span><span class="n">GraphException</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;The exception is raised when the vertex already exists in the graph.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="DuplicateEdgeError">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.DuplicateEdgeError">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DuplicateEdgeError</span><span class="p">(</span><span class="n">GraphException</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;The exception is raised when the edge already exists in the graph.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="DestinationNotReachable">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.DestinationNotReachable">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DestinationNotReachable</span><span class="p">(</span><span class="n">GraphException</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;The exception is raised when a destination vertex is not reachable.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="NotATreeError">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.NotATreeError">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NotATreeError</span><span class="p">(</span><span class="n">GraphException</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	The exception is raised when a subgraph is not a tree.</span>

<span class="sd">	Either the subgraph has a cycle (backward edge) or links between branches (cross-edge).</span>
<span class="sd">	&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="CycleError">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.CycleError">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CycleError</span><span class="p">(</span><span class="n">GraphException</span><span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;The exception is raised when a not permitted cycle is found.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="Base">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Base">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="p">(</span>
	<span class="n">Generic</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">],</span>
	<span class="n">metaclass</span><span class="o">=</span><span class="n">ExtendedType</span><span class="p">,</span> <span class="n">slots</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
	<span class="n">_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]</span>  <span class="c1">#: A dictionary to store arbitrary key-value-pairs.</span>

<div class="viewcode-block" id="Base.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Base.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Base::init Needs documentation.</span>

<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">keyValuePairs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="k">if</span> <span class="n">keyValuePairs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="Base.__del__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Base.__del__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Base::del Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span>
		<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
			<span class="k">pass</span></div>


	<span class="k">def</span><span class="w"> </span><span class="nf">Delete</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Base.__getitem__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Base.__getitem__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">DictKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DictValueType</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read a vertex&#39;s attached attributes (key-value-pairs) by key.</span>

<span class="sd">		:param key: The key to look for.</span>
<span class="sd">		:returns:   The value associated to the given key.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Base.__setitem__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Base.__setitem__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">DictKeyType</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">DictValueType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Create or update a vertex&#39;s attached attributes (key-value-pairs) by key.</span>

<span class="sd">		If a key doesn&#39;t exist yet, a new key-value-pair is created.</span>

<span class="sd">		:param key: The key to create or update.</span>
<span class="sd">		:param value: The value to associate to the given key.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Base.__delitem__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Base.__delitem__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">DictKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Remove an entry from vertex&#39;s attached attributes (key-value-pairs) by key.</span>

<span class="sd">		:param key:       The key to remove.</span>
<span class="sd">		:raises KeyError: If key doesn&#39;t exist in the vertex&#39;s attributes.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Base.__contains__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Base.__contains__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">DictKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks if the key is an attached attribute (key-value-pairs) on this vertex.</span>

<span class="sd">		:param key: The key to check.</span>
<span class="sd">		:returns:   ``True``, if the key is an attached attribute.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span></div>


<div class="viewcode-block" id="Base.__len__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Base.__len__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the number of attached attributes (key-value-pairs) on this vertex.</span>

<span class="sd">		:returns: Number of attached attributes.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="BaseWithIDValueAndWeight">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseWithIDValueAndWeight">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseWithIDValueAndWeight</span><span class="p">(</span>
	<span class="n">Base</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span><span class="n">IDType</span><span class="p">,</span> <span class="n">ValueType</span><span class="p">,</span> <span class="n">WeightType</span><span class="p">,</span> <span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]</span>
<span class="p">):</span>
	<span class="n">_id</span><span class="p">:</span>        <span class="n">Nullable</span><span class="p">[</span><span class="n">IDType</span><span class="p">]</span>      <span class="c1">#: Field storing the object&#39;s Identifier.</span>
	<span class="n">_value</span><span class="p">:</span>     <span class="n">Nullable</span><span class="p">[</span><span class="n">ValueType</span><span class="p">]</span>   <span class="c1">#: Field storing the object&#39;s value of any type.</span>
	<span class="n">_weight</span><span class="p">:</span>    <span class="n">Nullable</span><span class="p">[</span><span class="n">WeightType</span><span class="p">]</span>  <span class="c1">#: Field storing the object&#39;s weight.</span>

<div class="viewcode-block" id="BaseWithIDValueAndWeight.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseWithIDValueAndWeight.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">identifier</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">IDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">value</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">ValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">weight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">WeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Vertex::init Needs documentation.</span>

<span class="sd">		:param identifier:    The optional unique ID.</span>
<span class="sd">		:param value:         The optional value.</span>
<span class="sd">		:param weight:        The optional weight.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keyValuePairs</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="n">identifier</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_weight</span> <span class="o">=</span> <span class="n">weight</span></div>


	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">ID</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">IDType</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to access the unique ID (:attr:`_id`).</span>

<span class="sd">		If no ID was given at creation time, ID returns ``None``.</span>

<span class="sd">		:returns: Unique ID, if ID was given at creation time, else ``None``.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>

	<span class="nd">@property</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Property to get and set the value (:attr:`_value`).</span>

<span class="sd">		:returns: The value.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

	<span class="nd">@Value</span><span class="o">.</span><span class="n">setter</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ValueType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>

	<span class="nd">@property</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeWeightType</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Property to get and set the weight (:attr:`_weight`) of an edge.</span>

<span class="sd">		:returns: The weight of an edge.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span>

	<span class="nd">@Weight</span><span class="o">.</span><span class="n">setter</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeWeightType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_weight</span> <span class="o">=</span> <span class="n">value</span></div>



<div class="viewcode-block" id="BaseWithName">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseWithName">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseWithName</span><span class="p">(</span>
	<span class="n">Base</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]</span>
<span class="p">):</span>
	<span class="n">_name</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>  <span class="c1">#: Field storing the object&#39;s name.</span>

<div class="viewcode-block" id="BaseWithName.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseWithName.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">name</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::BaseWithName::init Needs documentation.</span>

<span class="sd">		:param name:          The optional name.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;name&#39; is not of type &#39;str&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keyValuePairs</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span></div>


	<span class="nd">@property</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Property to get and set the name (:attr:`_name`).</span>

<span class="sd">		:returns: The value of a component.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

	<span class="nd">@Name</span><span class="o">.</span><span class="n">setter</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Name is not of type &#39;str&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">value</span></div>



<div class="viewcode-block" id="BaseWithVertices">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseWithVertices">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseWithVertices</span><span class="p">(</span>
	<span class="n">BaseWithName</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span>
		<span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">,</span>
		<span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">]</span>
<span class="p">):</span>
	<span class="n">_graph</span><span class="p">:</span>    <span class="s1">&#39;Graph[GraphDictKeyType, GraphDictValueType,&#39;</span> \
								<span class="s1">&#39;VertexIDType, VertexWeightType, VertexValueType, VertexDictKeyType, VertexDictValueType,&#39;</span> \
								<span class="s1">&#39;EdgeIDType, EdgeWeightType, EdgeValueType, EdgeDictKeyType, EdgeDictValueType,&#39;</span> \
								<span class="s1">&#39;LinkIDType, LinkWeightType, LinkValueType, LinkDictKeyType, LinkDictValueType&#39;</span> \
								<span class="s1">&#39;]&#39;</span>   <span class="c1">#: Field storing a reference to the graph.</span>
	<span class="n">_vertices</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="s1">&#39;Vertex[GraphDictKeyType, GraphDictValueType,&#39;</span>
								<span class="s1">&#39;VertexIDType, VertexWeightType, VertexValueType, VertexDictKeyType, VertexDictValueType,&#39;</span>
								<span class="s1">&#39;EdgeIDType, EdgeWeightType, EdgeValueType, EdgeDictKeyType, EdgeDictValueType,&#39;</span>
								<span class="s1">&#39;LinkIDType, LinkWeightType, LinkValueType, LinkDictKeyType, LinkDictValueType&#39;</span>
								<span class="s1">&#39;]&#39;</span><span class="p">]</span>  <span class="c1">#: Field storing a set of vertices.</span>

<div class="viewcode-block" id="BaseWithVertices.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseWithVertices.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">graph</span><span class="p">:</span> <span class="s1">&#39;Graph&#39;</span><span class="p">,</span>
		<span class="n">name</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">vertices</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Component::init Needs documentation.</span>

<span class="sd">		:param graph:         The reference to the graph.</span>
<span class="sd">		:param name:          The optional name.</span>
<span class="sd">		:param vertices:      The optional list of vertices.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;graph&#39; is None.&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;graph&#39; is not of type &#39;Graph&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">}</span></div>


<div class="viewcode-block" id="BaseWithVertices.__del__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseWithVertices.__del__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::BaseWithVertices::del Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span>
		<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
			<span class="k">pass</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span></div>


	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Graph&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to access the graph, this object is associated to (:attr:`_graph`).</span>

<span class="sd">		:returns: The graph this object is associated to.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to access the vertices in this component (:attr:`_vertices`).</span>

<span class="sd">		:returns: The set of vertices in this component.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">VertexCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to access the number of vertices referenced by this object.</span>

<span class="sd">		:returns: The number of vertices this object references.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span></div>



<div class="viewcode-block" id="Vertex">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Vertex</span><span class="p">(</span>
	<span class="n">BaseWithIDValueAndWeight</span><span class="p">[</span><span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span>
		<span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">]</span>
<span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	A **vertex** can have a unique ID, a value and attached meta information as key-value-pairs. A vertex has references</span>
<span class="sd">	to inbound and outbound edges, thus a graph can be traversed in reverse.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">_graph</span><span class="p">:</span>     <span class="s1">&#39;BaseGraph[GraphDictKeyType, GraphDictValueType, VertexIDType, VertexWeightType, VertexValueType, VertexDictKeyType, VertexDictValueType, EdgeIDType, EdgeWeightType, EdgeValueType, EdgeDictKeyType, EdgeDictValueType]&#39;</span>  <span class="c1">#: Field storing a reference to the graph.</span>
	<span class="n">_subgraph</span><span class="p">:</span>  <span class="s1">&#39;Subgraph[GraphDictKeyType, GraphDictValueType, VertexIDType, VertexWeightType, VertexValueType, VertexDictKeyType, VertexDictValueType, EdgeIDType, EdgeWeightType, EdgeValueType, EdgeDictKeyType, EdgeDictValueType]&#39;</span>   <span class="c1">#: Field storing a reference to the subgraph.</span>
	<span class="n">_component</span><span class="p">:</span> <span class="s1">&#39;Component&#39;</span>
	<span class="n">_views</span><span class="p">:</span>     <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="s1">&#39;View&#39;</span><span class="p">]</span>
	<span class="n">_inboundEdges</span><span class="p">:</span>   <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Edge[EdgeIDType, EdgeWeightType, EdgeValueType, EdgeDictKeyType, EdgeDictValueType]&#39;</span><span class="p">]</span>  <span class="c1">#: Field storing a list of inbound edges.</span>
	<span class="n">_outboundEdges</span><span class="p">:</span>  <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Edge[EdgeIDType, EdgeWeightType, EdgeValueType, EdgeDictKeyType, EdgeDictValueType]&#39;</span><span class="p">]</span>  <span class="c1">#: Field storing a list of outbound edges.</span>
	<span class="n">_inboundLinks</span><span class="p">:</span>   <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Link[EdgeIDType, EdgeWeightType, EdgeValueType, EdgeDictKeyType, EdgeDictValueType]&#39;</span><span class="p">]</span>  <span class="c1">#: Field storing a list of inbound links.</span>
	<span class="n">_outboundLinks</span><span class="p">:</span>  <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Link[EdgeIDType, EdgeWeightType, EdgeValueType, EdgeDictKeyType, EdgeDictValueType]&#39;</span><span class="p">]</span>  <span class="c1">#: Field storing a list of outbound links.</span>

<div class="viewcode-block" id="Vertex.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">vertexID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">value</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">weight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">graph</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="s1">&#39;Graph&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">subgraph</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="s1">&#39;Subgraph&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Vertex::init Needs documentation.</span>

<span class="sd">		:param vertexID:      The optional ID for the new vertex.</span>
<span class="sd">		:param value:         The optional value for the new vertex.</span>
<span class="sd">		:param weight:        The optional weight for the new vertex.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		:param graph:         The optional reference to the graph.</span>
<span class="sd">		:param subgraph:      undocumented</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">vertexID</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vertexID</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;vertexID&#39; is not of type &#39;VertexIDType&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">vertexID</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">vertexID</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">subgraph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span> <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Graph</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_component</span> <span class="o">=</span> <span class="n">Component</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,))</span>

			<span class="k">if</span> <span class="n">vertexID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">vertexID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="p">[</span><span class="n">vertexID</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="n">DuplicateVertexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Vertex ID &#39;</span><span class="si">{</span><span class="n">vertexID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">subgraph</span><span class="o">.</span><span class="n">_graph</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="o">=</span> <span class="n">subgraph</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_component</span> <span class="o">=</span> <span class="n">Component</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,))</span>

			<span class="k">if</span> <span class="n">vertexID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">subgraph</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">vertexID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subgraph</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="p">:</span>
				<span class="n">subgraph</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="p">[</span><span class="n">vertexID</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="n">DuplicateVertexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Vertex ID &#39;</span><span class="si">{</span><span class="n">vertexID</span><span class="si">}</span><span class="s2">&#39; already exists in this subgraph.&quot;</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_views</span> <span class="o">=</span>         <span class="p">{}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span> <span class="o">=</span>  <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span> <span class="o">=</span>  <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Vertex.__del__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.__del__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::BaseEdge::del Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span>
		<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
			<span class="k">pass</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span></div>


	<span class="k">def</span><span class="w"> </span><span class="nf">Delete</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
			<span class="n">edge</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
			<span class="n">edge</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">:</span>
			<span class="n">edge</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
			<span class="n">edge</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="p">:</span>
			<span class="n">link</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
			<span class="n">link</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="p">:</span>
			<span class="n">link</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
			<span class="n">link</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">]</span>

		<span class="c1"># subgraph</span>

		<span class="c1"># component</span>

		<span class="c1"># views</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_views</span> <span class="o">=</span>         <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span> <span class="o">=</span>  <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span> <span class="o">=</span>  <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">Delete</span><span class="p">()</span>
		<span class="k">assert</span> <span class="n">getrefcount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Graph&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to access the graph, this vertex is associated to (:attr:`_graph`).</span>

<span class="sd">		:returns: The graph this vertex is associated to.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Component</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Component&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to access the component, this vertex is associated to (:attr:`_component`).</span>

<span class="sd">		:returns: The component this vertex is associated to.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_component</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">InboundEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Edge&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get a tuple of inbound edges (:attr:`_inboundEdges`).</span>

<span class="sd">		:returns: Tuple of inbound edges.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">OutboundEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Edge&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get a tuple of outbound edges (:attr:`_outboundEdges`).</span>

<span class="sd">		:returns: Tuple of outbound edges.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">InboundLinks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Link&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get a tuple of inbound links (:attr:`_inboundLinks`).</span>

<span class="sd">		:returns: Tuple of inbound links.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">OutboundLinks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Link&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get a tuple of outbound links (:attr:`_outboundLinks`).</span>

<span class="sd">		:returns: Tuple of outbound links.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">EdgeCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get the number of all edges (inbound and outbound).</span>

<span class="sd">		:returns: Number of inbound and outbound edges.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">InboundEdgeCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get the number of inbound edges.</span>

<span class="sd">		:returns: Number of inbound edges.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">OutboundEdgeCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get the number of outbound edges.</span>

<span class="sd">		:returns: Number of outbound edges.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">LinkCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get the number of all links (inbound and outbound).</span>

<span class="sd">		:returns: Number of inbound and outbound links.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">InboundLinkCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get the number of inbound links.</span>

<span class="sd">		:returns: Number of inbound links.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">OutboundLinkCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get the number of outbound links.</span>

<span class="sd">		:returns: Number of outbound links.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">IsRoot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to check if this vertex is a root vertex in the graph.</span>

<span class="sd">		A root has no inbound edges (no predecessor vertices).</span>

<span class="sd">		:returns: ``True``, if this vertex is a root.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`IsLeaf` |br|</span>
<span class="sd">		      |rarr| Check if a vertex is a leaf vertex in the graph.</span>
<span class="sd">		   :meth:`Graph.IterateRoots &lt;pyTooling.Graph.Graph.IterateRoots&gt;` |br|</span>
<span class="sd">		      |rarr| Iterate all roots of a graph.</span>
<span class="sd">		   :meth:`Graph.IterateLeafs &lt;pyTooling.Graph.Graph.IterateLeafs&gt;` |br|</span>
<span class="sd">		      |rarr| Iterate all leafs of a graph.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">IsLeaf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to check if this vertex is a leaf vertex in the graph.</span>

<span class="sd">		A leaf has no outbound edges (no successor vertices).</span>

<span class="sd">		:returns: ``True``, if this vertex is a leaf.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`IsRoot` |br|</span>
<span class="sd">		      |rarr| Check if a vertex is a root vertex in the graph.</span>
<span class="sd">		   :meth:`Graph.IterateRoots &lt;pyTooling.Graph.Graph.IterateRoots&gt;` |br|</span>
<span class="sd">		      |rarr| Iterate all roots of a graph.</span>
<span class="sd">		   :meth:`Graph.IterateLeafs &lt;pyTooling.Graph.Graph.IterateLeafs&gt;` |br|</span>
<span class="sd">		      |rarr| Iterate all leafs of a graph.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Predecessors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get a tuple of predecessor vertices.</span>

<span class="sd">		:returns: Tuple of predecessor vertices.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">edge</span><span class="o">.</span><span class="n">Source</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">])</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Successors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get a tuple of successor vertices.</span>

<span class="sd">		:returns: Tuple of successor vertices.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">edge</span><span class="o">.</span><span class="n">Destination</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">])</span>

<div class="viewcode-block" id="Vertex.EdgeToVertex">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.EdgeToVertex">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">EdgeToVertex</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">vertex</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">,</span>
		<span class="n">edgeID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeWeight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeValue</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Edge&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Create an outbound edge from this vertex to the referenced vertex.</span>

<span class="sd">		:param vertex:        The vertex to be linked to.</span>
<span class="sd">		:param edgeID:        The edge&#39;s optional ID for the new edge object.</span>
<span class="sd">		:param edgeWeight:    The edge&#39;s optional weight for the new edge object.</span>
<span class="sd">		:param edgeValue:     The edge&#39;s optional value for the new edge object.</span>
<span class="sd">		:param keyValuePairs: An optional mapping (dictionary) of key-value-pairs for the new edge object.</span>
<span class="sd">		:returns:             The edge object linking this vertex and the referenced vertex.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`EdgeFromVertex` |br|</span>
<span class="sd">		      |rarr| Create an inbound edge from the referenced vertex to this vertex.</span>
<span class="sd">		   :meth:`EdgeToNewVertex` |br|</span>
<span class="sd">		      |rarr| Create a new vertex and link that vertex by an outbound edge from this vertex.</span>
<span class="sd">		   :meth:`EdgeFromNewVertex` |br|</span>
<span class="sd">		      |rarr| Create a new vertex and link that vertex by an inbound edge to this vertex.</span>
<span class="sd">		   :meth:`LinkToVertex` |br|</span>
<span class="sd">		      |rarr| Create an outbound link from this vertex to the referenced vertex.</span>
<span class="sd">		   :meth:`LinkFromVertex` |br|</span>
<span class="sd">		      |rarr| Create an inbound link from the referenced vertex to this vertex.</span>

<span class="sd">		.. todo:: GRAPH::Vertex::EdgeToVertex Needs possible exceptions to be documented.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_subgraph</span><span class="p">:</span>
			<span class="n">edge</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">edgeID</span><span class="p">,</span> <span class="n">edgeValue</span><span class="p">,</span> <span class="n">edgeWeight</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
			<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="c1"># TODO: move into Edge?</span>
				<span class="c1"># TODO: keep _graph pointer in edge and then register edge on graph?</span>
				<span class="k">if</span> <span class="n">edgeID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">edgeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="n">edgeID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge ID &#39;</span><span class="si">{</span><span class="n">edgeID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># TODO: keep _graph pointer in edge and then register edge on graph?</span>
				<span class="k">if</span> <span class="n">edgeID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">edgeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="n">edgeID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge ID &#39;</span><span class="si">{</span><span class="n">edgeID</span><span class="si">}</span><span class="s2">&#39; already exists in this subgraph.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># FIXME: needs an error message</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">()</span>

		<span class="k">return</span> <span class="n">edge</span></div>


<div class="viewcode-block" id="Vertex.EdgeFromVertex">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.EdgeFromVertex">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">EdgeFromVertex</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">vertex</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">,</span>
		<span class="n">edgeID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeWeight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeValue</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Edge&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Create an inbound edge from the referenced vertex to this vertex.</span>

<span class="sd">		:param vertex:        The vertex to be linked from.</span>
<span class="sd">		:param edgeID:        The edge&#39;s optional ID for the new edge object.</span>
<span class="sd">		:param edgeWeight:    The edge&#39;s optional weight for the new edge object.</span>
<span class="sd">		:param edgeValue:     The edge&#39;s optional value for the new edge object.</span>
<span class="sd">		:param keyValuePairs: An optional mapping (dictionary) of key-value-pairs for the new edge object.</span>
<span class="sd">		:returns:             The edge object linking the referenced vertex and this vertex.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`EdgeToVertex` |br|</span>
<span class="sd">		      |rarr| Create an outbound edge from this vertex to the referenced vertex.</span>
<span class="sd">		   :meth:`EdgeToNewVertex` |br|</span>
<span class="sd">		      |rarr| Create a new vertex and link that vertex by an outbound edge from this vertex.</span>
<span class="sd">		   :meth:`EdgeFromNewVertex` |br|</span>
<span class="sd">		      |rarr| Create a new vertex and link that vertex by an inbound edge to this vertex.</span>
<span class="sd">		   :meth:`LinkToVertex` |br|</span>
<span class="sd">		      |rarr| Create an outbound link from this vertex to the referenced vertex.</span>
<span class="sd">		   :meth:`LinkFromVertex` |br|</span>
<span class="sd">		      |rarr| Create an inbound link from the referenced vertex to this vertex.</span>

<span class="sd">		.. todo:: GRAPH::Vertex::EdgeFromVertex Needs possible exceptions to be documented.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_subgraph</span><span class="p">:</span>
			<span class="n">edge</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">edgeID</span><span class="p">,</span> <span class="n">edgeValue</span><span class="p">,</span> <span class="n">edgeWeight</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

			<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="c1"># TODO: move into Edge?</span>
				<span class="c1"># TODO: keep _graph pointer in edge and then register edge on graph?</span>
				<span class="k">if</span> <span class="n">edgeID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">edgeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="n">edgeID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge ID &#39;</span><span class="si">{</span><span class="n">edgeID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># TODO: keep _graph pointer in edge and then register edge on graph?</span>
				<span class="k">if</span> <span class="n">edgeID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">edgeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="n">edgeID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge ID &#39;</span><span class="si">{</span><span class="n">edgeID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># FIXME: needs an error message</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">()</span>

		<span class="k">return</span> <span class="n">edge</span></div>


<div class="viewcode-block" id="Vertex.EdgeToNewVertex">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.EdgeToNewVertex">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">EdgeToNewVertex</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">vertexID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">vertexValue</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">vertexWeight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">vertexKeyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeWeight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeValue</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeKeyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Edge&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Create a new vertex and link that vertex by an outbound edge from this vertex.</span>

<span class="sd">		:param vertexID:            The new vertex&#39; optional ID.</span>
<span class="sd">		:param vertexValue:         The new vertex&#39; optional value.</span>
<span class="sd">		:param vertexWeight:        The new vertex&#39; optional weight.</span>
<span class="sd">		:param vertexKeyValuePairs: An optional mapping (dictionary) of key-value-pairs for the new vertex.</span>
<span class="sd">		:param edgeID:              The edge&#39;s optional ID for the new edge object.</span>
<span class="sd">		:param edgeWeight:          The edge&#39;s optional weight for the new edge object.</span>
<span class="sd">		:param edgeValue:           The edge&#39;s optional value for the new edge object.</span>
<span class="sd">		:param edgeKeyValuePairs:   An optional mapping (dictionary) of key-value-pairs for the new edge object.</span>
<span class="sd">		:returns:                   The edge object linking this vertex and the created vertex.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`EdgeToVertex` |br|</span>
<span class="sd">		      |rarr| Create an outbound edge from this vertex to the referenced vertex.</span>
<span class="sd">		   :meth:`EdgeFromVertex` |br|</span>
<span class="sd">		      |rarr| Create an inbound edge from the referenced vertex to this vertex.</span>
<span class="sd">		   :meth:`EdgeFromNewVertex` |br|</span>
<span class="sd">		      |rarr| Create a new vertex and link that vertex by an inbound edge to this vertex.</span>
<span class="sd">		   :meth:`LinkToVertex` |br|</span>
<span class="sd">		      |rarr| Create an outbound link from this vertex to the referenced vertex.</span>
<span class="sd">		   :meth:`LinkFromVertex` |br|</span>
<span class="sd">		      |rarr| Create an inbound link from the referenced vertex to this vertex.</span>

<span class="sd">		.. todo:: GRAPH::Vertex::EdgeToNewVertex Needs possible exceptions to be documented.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">vertex</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="n">vertexID</span><span class="p">,</span> <span class="n">vertexValue</span><span class="p">,</span> <span class="n">vertexWeight</span><span class="p">,</span> <span class="n">vertexKeyValuePairs</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">)</span>  <span class="c1"># , component=self._component)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_subgraph</span><span class="p">:</span>
			<span class="n">edge</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">edgeID</span><span class="p">,</span> <span class="n">edgeValue</span><span class="p">,</span> <span class="n">edgeWeight</span><span class="p">,</span> <span class="n">edgeKeyValuePairs</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
			<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="c1"># TODO: move into Edge?</span>
				<span class="c1"># TODO: keep _graph pointer in edge and then register edge on graph?</span>
				<span class="k">if</span> <span class="n">edgeID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">edgeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="n">edgeID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge ID &#39;</span><span class="si">{</span><span class="n">edgeID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># TODO: keep _graph pointer in edge and then register edge on graph?</span>
				<span class="k">if</span> <span class="n">edgeID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">edgeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="n">edgeID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge ID &#39;</span><span class="si">{</span><span class="n">edgeID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># FIXME: needs an error message</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">()</span>

		<span class="k">return</span> <span class="n">edge</span></div>


<div class="viewcode-block" id="Vertex.EdgeFromNewVertex">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.EdgeFromNewVertex">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">EdgeFromNewVertex</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">vertexID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">vertexValue</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">vertexWeight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">vertexKeyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeWeight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeValue</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">edgeKeyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Edge&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Create a new vertex and link that vertex by an inbound edge to this vertex.</span>

<span class="sd">		:param vertexID:            The new vertex&#39; optional ID.</span>
<span class="sd">		:param vertexValue:         The new vertex&#39; optional value.</span>
<span class="sd">		:param vertexWeight:        The new vertex&#39; optional weight.</span>
<span class="sd">		:param vertexKeyValuePairs: An optional mapping (dictionary) of key-value-pairs for the new vertex.</span>
<span class="sd">		:param edgeID:              The edge&#39;s optional ID for the new edge object.</span>
<span class="sd">		:param edgeWeight:          The edge&#39;s optional weight for the new edge object.</span>
<span class="sd">		:param edgeValue:           The edge&#39;s optional value for the new edge object.</span>
<span class="sd">		:param edgeKeyValuePairs:   An optional mapping (dictionary) of key-value-pairs for the new edge object.</span>
<span class="sd">		:returns:                   The edge object linking this vertex and the created vertex.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`EdgeToVertex` |br|</span>
<span class="sd">		      |rarr| Create an outbound edge from this vertex to the referenced vertex.</span>
<span class="sd">		   :meth:`EdgeFromVertex` |br|</span>
<span class="sd">		      |rarr| Create an inbound edge from the referenced vertex to this vertex.</span>
<span class="sd">		   :meth:`EdgeToNewVertex` |br|</span>
<span class="sd">		      |rarr| Create a new vertex and link that vertex by an outbound edge from this vertex.</span>
<span class="sd">		   :meth:`LinkToVertex` |br|</span>
<span class="sd">		      |rarr| Create an outbound link from this vertex to the referenced vertex.</span>
<span class="sd">		   :meth:`LinkFromVertex` |br|</span>
<span class="sd">		      |rarr| Create an inbound link from the referenced vertex to this vertex.</span>

<span class="sd">		.. todo:: GRAPH::Vertex::EdgeFromNewVertex Needs possible exceptions to be documented.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">vertex</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="n">vertexID</span><span class="p">,</span> <span class="n">vertexValue</span><span class="p">,</span> <span class="n">vertexWeight</span><span class="p">,</span> <span class="n">vertexKeyValuePairs</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">)</span>  <span class="c1"># , component=self._component)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_subgraph</span><span class="p">:</span>
			<span class="n">edge</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">edgeID</span><span class="p">,</span> <span class="n">edgeValue</span><span class="p">,</span> <span class="n">edgeWeight</span><span class="p">,</span> <span class="n">edgeKeyValuePairs</span><span class="p">)</span>

			<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="c1"># TODO: move into Edge?</span>
				<span class="c1"># TODO: keep _graph pointer in edge and then register edge on graph?</span>
				<span class="k">if</span> <span class="n">edgeID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">edgeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="n">edgeID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge ID &#39;</span><span class="si">{</span><span class="n">edgeID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># TODO: keep _graph pointer in edge and then register edge on graph?</span>
				<span class="k">if</span> <span class="n">edgeID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">edgeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="n">edgeID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge ID &#39;</span><span class="si">{</span><span class="n">edgeID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># FIXME: needs an error message</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">()</span>

		<span class="k">return</span> <span class="n">edge</span></div>


<div class="viewcode-block" id="Vertex.LinkToVertex">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.LinkToVertex">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">LinkToVertex</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">vertex</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">,</span>
		<span class="n">linkID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">linkWeight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">linkValue</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Link&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Create an outbound link from this vertex to the referenced vertex.</span>

<span class="sd">		:param vertex:        The vertex to be linked to.</span>
<span class="sd">		:param edgeID:        The edge&#39;s optional ID for the new link object.</span>
<span class="sd">		:param edgeWeight:    The edge&#39;s optional weight for the new link object.</span>
<span class="sd">		:param edgeValue:     The edge&#39;s optional value for the new link object.</span>
<span class="sd">		:param keyValuePairs: An optional mapping (dictionary) of key-value-pairs for the new link object.</span>
<span class="sd">		:returns:             The link object linking this vertex and the referenced vertex.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`EdgeToVertex` |br|</span>
<span class="sd">		      |rarr| Create an outbound edge from this vertex to the referenced vertex.</span>
<span class="sd">		   :meth:`EdgeFromVertex` |br|</span>
<span class="sd">		      |rarr| Create an inbound edge from the referenced vertex to this vertex.</span>
<span class="sd">		   :meth:`EdgeToNewVertex` |br|</span>
<span class="sd">		      |rarr| Create a new vertex and link that vertex by an outbound edge from this vertex.</span>
<span class="sd">		   :meth:`EdgeFromNewVertex` |br|</span>
<span class="sd">		      |rarr| Create a new vertex and link that vertex by an inbound edge to this vertex.</span>
<span class="sd">		   :meth:`LinkFromVertex` |br|</span>
<span class="sd">		      |rarr| Create an inbound link from the referenced vertex to this vertex.</span>

<span class="sd">		.. todo:: GRAPH::Vertex::LinkToVertex Needs possible exceptions to be documented.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_subgraph</span><span class="p">:</span>
			<span class="c1"># FIXME: needs an error message</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">link</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">linkID</span><span class="p">,</span> <span class="n">linkValue</span><span class="p">,</span> <span class="n">linkWeight</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
			<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="c1"># TODO: move into Edge?</span>
				<span class="c1"># TODO: keep _graph pointer in link and then register link on graph?</span>
				<span class="k">if</span> <span class="n">linkID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">linkID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">[</span><span class="n">linkID</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Link ID &#39;</span><span class="si">{</span><span class="n">linkID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># TODO: keep _graph pointer in link and then register link on graph?</span>
				<span class="k">if</span> <span class="n">linkID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
					<span class="n">vertex</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">linkID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">[</span><span class="n">linkID</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
					<span class="n">vertex</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">[</span><span class="n">linkID</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Link ID &#39;</span><span class="si">{</span><span class="n">linkID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">link</span></div>


<div class="viewcode-block" id="Vertex.LinkFromVertex">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.LinkFromVertex">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">LinkFromVertex</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">vertex</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">,</span>
		<span class="n">linkID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">linkWeight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">linkValue</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Edge&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Create an inbound link from the referenced vertex to this vertex.</span>

<span class="sd">		:param vertex:        The vertex to be linked from.</span>
<span class="sd">		:param edgeID:        The edge&#39;s optional ID for the new link object.</span>
<span class="sd">		:param edgeWeight:    The edge&#39;s optional weight for the new link object.</span>
<span class="sd">		:param edgeValue:     The edge&#39;s optional value for the new link object.</span>
<span class="sd">		:param keyValuePairs: An optional mapping (dictionary) of key-value-pairs for the new link object.</span>
<span class="sd">		:returns:             The link object linking the referenced vertex and this vertex.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`EdgeToVertex` |br|</span>
<span class="sd">		      |rarr| Create an outbound edge from this vertex to the referenced vertex.</span>
<span class="sd">		   :meth:`EdgeFromVertex` |br|</span>
<span class="sd">		      |rarr| Create an inbound edge from the referenced vertex to this vertex.</span>
<span class="sd">		   :meth:`EdgeToNewVertex` |br|</span>
<span class="sd">		      |rarr| Create a new vertex and link that vertex by an outbound edge from this vertex.</span>
<span class="sd">		   :meth:`EdgeFromNewVertex` |br|</span>
<span class="sd">		      |rarr| Create a new vertex and link that vertex by an inbound edge to this vertex.</span>
<span class="sd">		   :meth:`LinkToVertex` |br|</span>
<span class="sd">		      |rarr| Create an outbound link from this vertex to the referenced vertex.</span>

<span class="sd">		.. todo:: GRAPH::Vertex::LinkFromVertex Needs possible exceptions to be documented.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_subgraph</span><span class="p">:</span>
			<span class="c1"># FIXME: needs an error message</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">link</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">linkID</span><span class="p">,</span> <span class="n">linkValue</span><span class="p">,</span> <span class="n">linkWeight</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

			<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="c1"># TODO: move into Edge?</span>
				<span class="c1"># TODO: keep _graph pointer in link and then register link on graph?</span>
				<span class="k">if</span> <span class="n">linkID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">linkID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">[</span><span class="n">linkID</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Link ID &#39;</span><span class="si">{</span><span class="n">linkID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># TODO: keep _graph pointer in link and then register link on graph?</span>
				<span class="k">if</span> <span class="n">linkID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
					<span class="n">vertex</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
				<span class="k">elif</span> <span class="n">linkID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">[</span><span class="n">linkID</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
					<span class="n">vertex</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">[</span><span class="n">linkID</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">DuplicateEdgeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Link ID &#39;</span><span class="si">{</span><span class="n">linkID</span><span class="si">}</span><span class="s2">&#39; already exists in this graph.&quot;</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">link</span></div>


<div class="viewcode-block" id="Vertex.HasEdgeToDestination">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.HasEdgeToDestination">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">HasEdgeToDestination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Check if this vertex is linked to another vertex by any outbound edge.</span>

<span class="sd">		:param destination: Destination vertex to check.</span>
<span class="sd">		:returns:           ``True``, if the destination vertex is a destination on any outbound edge.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`HasEdgeFromSource` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any inbound edge.</span>
<span class="sd">		   :meth:`HasLinkToDestination` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any outbound link.</span>
<span class="sd">		   :meth:`HasLinkFromSource` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any inbound link.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">destination</span> <span class="ow">is</span> <span class="n">edge</span><span class="o">.</span><span class="n">Destination</span><span class="p">:</span>
				<span class="k">return</span> <span class="kc">True</span>

		<span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Vertex.HasEdgeFromSource">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.HasEdgeFromSource">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">HasEdgeFromSource</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Check if this vertex is linked to another vertex by any inbound edge.</span>

<span class="sd">		:param source: Source vertex to check.</span>
<span class="sd">		:returns:      ``True``, if the source vertex is a source on any inbound edge.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`HasEdgeToDestination` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any outbound edge.</span>
<span class="sd">		   :meth:`HasLinkToDestination` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any outbound link.</span>
<span class="sd">		   :meth:`HasLinkFromSource` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any inbound link.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="n">edge</span><span class="o">.</span><span class="n">Source</span><span class="p">:</span>
				<span class="k">return</span> <span class="kc">True</span>

		<span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Vertex.HasLinkToDestination">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.HasLinkToDestination">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">HasLinkToDestination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Check if this vertex is linked to another vertex by any outbound link.</span>

<span class="sd">		:param destination: Destination vertex to check.</span>
<span class="sd">		:returns:           ``True``, if the destination vertex is a destination on any outbound link.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`HasEdgeToDestination` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any outbound edge.</span>
<span class="sd">		   :meth:`HasEdgeFromSource` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any inbound edge.</span>
<span class="sd">		   :meth:`HasLinkFromSource` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any inbound link.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">destination</span> <span class="ow">is</span> <span class="n">link</span><span class="o">.</span><span class="n">Destination</span><span class="p">:</span>
				<span class="k">return</span> <span class="kc">True</span>

		<span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Vertex.HasLinkFromSource">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.HasLinkFromSource">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">HasLinkFromSource</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Check if this vertex is linked to another vertex by any inbound link.</span>

<span class="sd">		:param source: Source vertex to check.</span>
<span class="sd">		:returns:      ``True``, if the source vertex is a source on any inbound link.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`HasEdgeToDestination` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any outbound edge.</span>
<span class="sd">		   :meth:`HasEdgeFromSource` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any inbound edge.</span>
<span class="sd">		   :meth:`HasLinkToDestination` |br|</span>
<span class="sd">		      |rarr| Check if this vertex is linked to another vertex by any outbound link.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="n">link</span><span class="o">.</span><span class="n">Source</span><span class="p">:</span>
				<span class="k">return</span> <span class="kc">True</span>

		<span class="k">return</span> <span class="kc">False</span></div>


	<span class="k">def</span><span class="w"> </span><span class="nf">DeleteEdgeTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">_destination</span> <span class="ow">is</span> <span class="n">destination</span><span class="p">:</span>
				<span class="k">break</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No outbound edge found to &#39;</span><span class="si">{</span><span class="n">destination</span><span class="si">!r}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

		<span class="n">edge</span><span class="o">.</span><span class="n">Delete</span><span class="p">()</span>

	<span class="k">def</span><span class="w"> </span><span class="nf">DeleteEdgeFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">_source</span> <span class="ow">is</span> <span class="n">source</span><span class="p">:</span>
				<span class="k">break</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No inbound edge found to &#39;</span><span class="si">{</span><span class="n">source</span><span class="si">!r}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

		<span class="n">edge</span><span class="o">.</span><span class="n">Delete</span><span class="p">()</span>

	<span class="k">def</span><span class="w"> </span><span class="nf">DeleteLinkTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">_destination</span> <span class="ow">is</span> <span class="n">destination</span><span class="p">:</span>
				<span class="k">break</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No outbound link found to &#39;</span><span class="si">{</span><span class="n">destination</span><span class="si">!r}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

		<span class="n">link</span><span class="o">.</span><span class="n">Delete</span><span class="p">()</span>

	<span class="k">def</span><span class="w"> </span><span class="nf">DeleteLinkFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">_source</span> <span class="ow">is</span> <span class="n">source</span><span class="p">:</span>
				<span class="k">break</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No inbound link found to &#39;</span><span class="si">{</span><span class="n">source</span><span class="si">!r}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

		<span class="n">link</span><span class="o">.</span><span class="n">Delete</span><span class="p">()</span>

<div class="viewcode-block" id="Vertex.Copy">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.Copy">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">Copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">copyDict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">linkingKeyToOriginalVertex</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">linkingKeyFromOriginalVertex</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Creates a copy of this vertex in another graph.</span>

<span class="sd">		Optionally, the vertex&#39;s attached attributes (key-value-pairs) can be copied and a linkage between both vertices</span>
<span class="sd">		can be established.</span>

<span class="sd">		:param graph:                        The graph, the vertex is created in.</span>
<span class="sd">		:param copyDict:                     If ``True``, copy all attached attributes into the new vertex.</span>
<span class="sd">		:param linkingKeyToOriginalVertex:   If not ``None``, add a key-value-pair using this parameter as key from new vertex to the original vertex.</span>
<span class="sd">		:param linkingKeyFromOriginalVertex: If not ``None``, add a key-value-pair using this parameter as key from original vertex to the new vertex.</span>
<span class="sd">		:returns:                            The newly created vertex.</span>
<span class="sd">		:raises GraphException:              If source graph and destination graph are the same.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">GraphException</span><span class="p">(</span><span class="s2">&quot;Graph to copy this vertex to, is the same graph.&quot;</span><span class="p">)</span>

		<span class="n">vertex</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">copyDict</span><span class="p">:</span>
			<span class="n">vertex</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

		<span class="k">if</span> <span class="n">linkingKeyToOriginalVertex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">vertex</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">linkingKeyToOriginalVertex</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
		<span class="k">if</span> <span class="n">linkingKeyFromOriginalVertex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="p">[</span><span class="n">linkingKeyFromOriginalVertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertex</span>

		<span class="k">return</span> <span class="n">vertex</span></div>


<div class="viewcode-block" id="Vertex.IterateOutboundEdges">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.IterateOutboundEdges">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateOutboundEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Edge&#39;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s1">&#39;Edge&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected outbound edges of this vertex.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip edges in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any edge and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all outbound edges.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">edge</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">edge</span></div>


<div class="viewcode-block" id="Vertex.IterateInboundEdges">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.IterateInboundEdges">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateInboundEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Edge&#39;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s1">&#39;Edge&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected inbound edges of this vertex.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip edges in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any edge and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all inbound edges.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">edge</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">edge</span></div>


<div class="viewcode-block" id="Vertex.IterateOutboundLinks">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.IterateOutboundLinks">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateOutboundLinks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Link&#39;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s1">&#39;Link&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected outbound links of this vertex.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip links in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any link and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all outbound links.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">link</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">link</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">link</span></div>


<div class="viewcode-block" id="Vertex.IterateInboundLinks">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.IterateInboundLinks">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateInboundLinks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Link&#39;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s1">&#39;Link&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected inbound links of this vertex.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip links in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any link and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all inbound links.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">link</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">link</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">link</span></div>


<div class="viewcode-block" id="Vertex.IterateSuccessorVertices">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.IterateSuccessorVertices">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateSuccessorVertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Edge&#39;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected successor vertices of this vertex.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip successors in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any edge and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all successor vertices.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">edge</span><span class="o">.</span><span class="n">Destination</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">edge</span><span class="o">.</span><span class="n">Destination</span></div>


<div class="viewcode-block" id="Vertex.IteratePredecessorVertices">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.IteratePredecessorVertices">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IteratePredecessorVertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Edge&#39;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected predecessor vertices of this vertex.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip predecessors in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any edge and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all predecessor vertices.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">edge</span><span class="o">.</span><span class="n">Source</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">edge</span><span class="o">.</span><span class="n">Source</span></div>


<div class="viewcode-block" id="Vertex.IterateVerticesBFS">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.IterateVerticesBFS">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateVerticesBFS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		A generator to iterate all reachable vertices starting from this node in breadth-first search (BFS) order.</span>

<span class="sd">		:returns: A generator to iterate vertices traversed in BFS order.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`IterateVerticesDFS` |br|</span>
<span class="sd">		      |rarr| Iterate all reachable vertices **depth-first search** order.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">visited</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="n">queue</span><span class="p">:</span> <span class="n">Deque</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

		<span class="k">yield</span> <span class="bp">self</span>
		<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
			<span class="n">nextVertex</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">Destination</span>
			<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
				<span class="n">queue</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
				<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>

		<span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
			<span class="n">vertex</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
			<span class="k">yield</span> <span class="n">vertex</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
				<span class="n">nextVertex</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">Destination</span>
				<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
					<span class="n">queue</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
					<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span></div>


<div class="viewcode-block" id="Vertex.IterateVerticesDFS">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.IterateVerticesDFS">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateVerticesDFS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		A generator to iterate all reachable vertices starting from this node in depth-first search (DFS) order.</span>

<span class="sd">		:returns: A generator to iterate vertices traversed in DFS order.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`IterateVerticesBFS` |br|</span>
<span class="sd">		      |rarr| Iterate all reachable vertices **breadth-first search** order.</span>

<span class="sd">		   Wikipedia - https://en.wikipedia.org/wiki/Depth-first_search</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">visited</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">typing_Iterator</span><span class="p">[</span><span class="n">Edge</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

		<span class="k">yield</span> <span class="bp">self</span>
		<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">))</span>

		<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">edge</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">nextVertex</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_destination</span>
				<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
					<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
					<span class="k">yield</span> <span class="n">nextVertex</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nextVertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
						<span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">nextVertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">))</span>
			<span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
				<span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">return</span></div>


	<span class="k">def</span><span class="w"> </span><span class="nf">IterateAllOutboundPathsAsVertexList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">yield</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">)</span>
			<span class="k">return</span>

		<span class="n">visited</span><span class="p">:</span>       <span class="n">Set</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]</span> <span class="o">=</span>                 <span class="nb">set</span><span class="p">()</span>
		<span class="n">vertexStack</span><span class="p">:</span>   <span class="n">List</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]</span> <span class="o">=</span>                <span class="nb">list</span><span class="p">()</span>
		<span class="n">iteratorStack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">typing_Iterator</span><span class="p">[</span><span class="n">Edge</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

		<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="n">vertexStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="n">iteratorStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">))</span>

		<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">edge</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iteratorStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">nextVertex</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_destination</span>
				<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
					<span class="n">ex</span> <span class="o">=</span> <span class="n">CycleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loop detected.&quot;</span><span class="p">)</span>
					<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First loop is:&quot;</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertexStack</span><span class="p">):</span>
						<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">vertex</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
					<span class="k">raise</span> <span class="n">ex</span>

				<span class="n">vertexStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nextVertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vertexStack</span><span class="p">)</span>
					<span class="n">vertexStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">iteratorStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">nextVertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">))</span>

			<span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
				<span class="n">vertexStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
				<span class="n">iteratorStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertexStack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">return</span>

<div class="viewcode-block" id="Vertex.ShortestPathToByHops">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.ShortestPathToByHops">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">ShortestPathToByHops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Compute the shortest path (by hops) between this vertex and the destination vertex.</span>

<span class="sd">		A generator is return to iterate all vertices along the path including source and destination vertex.</span>

<span class="sd">		The search algorithm is breadth-first search (BFS) based. The found solution, if any, is not unique but deterministic</span>
<span class="sd">		as long as the graph was not modified (e.g. ordering of edges on vertices).</span>

<span class="sd">		:param destination: The destination vertex to reach.</span>
<span class="sd">		:returns:           A generator to iterate all vertices on the path found between this vertex and the destination vertex.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># Trivial case if start is destination</span>
		<span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">destination</span><span class="p">:</span>
			<span class="k">yield</span> <span class="bp">self</span>
			<span class="k">return</span>

		<span class="c1"># Local struct to create multiple linked-lists forming a paths from current node back to the starting point</span>
		<span class="c1"># (actually a tree). Each node holds a reference to the vertex it represents.</span>
		<span class="c1"># Hint: slotted classes are faster than &#39;@dataclasses.dataclass&#39;.</span>
		<span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ExtendedType</span><span class="p">,</span> <span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
			<span class="n">parent</span><span class="p">:</span> <span class="s1">&#39;Node&#39;</span>
			<span class="n">ref</span><span class="p">:</span> <span class="n">Vertex</span>

			<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="s1">&#39;Node&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>

			<span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
				<span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Vertex: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">ID</span><span class="si">}</span><span class="s2">&quot;</span>

		<span class="c1"># Initially add all reachable vertices to a queue if vertices to be processed.</span>
		<span class="n">startNode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
		<span class="n">visited</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="n">queue</span><span class="p">:</span> <span class="n">Deque</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

		<span class="c1"># Add starting vertex and all its children to the processing list.</span>
		<span class="c1"># If a child is the destination, break immediately else go into &#39;else&#39; branch and use BFS algorithm.</span>
		<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
			<span class="n">nextVertex</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">Destination</span>
			<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">is</span> <span class="n">destination</span><span class="p">:</span>
				<span class="c1"># Child is destination, so construct the last node for path traversal and break from loop.</span>
				<span class="n">destinationNode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">startNode</span><span class="p">,</span> <span class="n">nextVertex</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
				<span class="c1"># Ignore backward-edges and side-edges.</span>
				<span class="c1"># Here self-edges, because there is only the starting vertex in the list of visited edges.</span>
				<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
				<span class="n">queue</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">startNode</span><span class="p">,</span> <span class="n">nextVertex</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># Process queue until destination is found or no further vertices are reachable.</span>
			<span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
				<span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
				<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
					<span class="n">nextVertex</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">Destination</span>
					<span class="c1"># Next reachable vertex is destination, so construct the last node for path traversal and break from loop.</span>
					<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">is</span> <span class="n">destination</span><span class="p">:</span>
						<span class="n">destinationNode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nextVertex</span><span class="p">)</span>
						<span class="k">break</span>
					<span class="c1"># Ignore backward-edges and side-edges.</span>
					<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
						<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
						<span class="n">queue</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nextVertex</span><span class="p">))</span>
				<span class="c1"># Next 3 lines realize a double-break if break was called in inner loop, otherwise continue with outer loop.</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">continue</span>
				<span class="k">break</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># All reachable vertices have been processed, but destination was not among them.</span>
				<span class="k">raise</span> <span class="n">DestinationNotReachable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Destination is not reachable.&quot;</span><span class="p">)</span>

		<span class="c1"># Reverse order of linked list from destinationNode to startNode</span>
		<span class="n">currentNode</span> <span class="o">=</span> <span class="n">destinationNode</span>
		<span class="n">previousNode</span> <span class="o">=</span> <span class="n">destinationNode</span><span class="o">.</span><span class="n">parent</span>
		<span class="n">currentNode</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">while</span> <span class="n">previousNode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">previousNode</span><span class="o">.</span><span class="n">parent</span>
			<span class="n">previousNode</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentNode</span>
			<span class="n">currentNode</span> <span class="o">=</span> <span class="n">previousNode</span>
			<span class="n">previousNode</span> <span class="o">=</span> <span class="n">node</span>

		<span class="c1"># Scan reversed linked-list and yield referenced vertices</span>
		<span class="k">yield</span> <span class="n">startNode</span><span class="o">.</span><span class="n">ref</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">startNode</span><span class="o">.</span><span class="n">parent</span>
		<span class="k">while</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">ref</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span></div>


<div class="viewcode-block" id="Vertex.ShortestPathToByWeight">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.ShortestPathToByWeight">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">ShortestPathToByWeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">:</span> <span class="s1">&#39;Vertex&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Compute the shortest path (by edge weight) between this vertex and the destination vertex.</span>

<span class="sd">		A generator is return to iterate all vertices along the path including source and destination vertex.</span>

<span class="sd">		The search algorithm is based on Dijkstra algorithm and using :mod:`heapq`. The found solution, if any, is not</span>
<span class="sd">		unique but deterministic as long as the graph was not modified (e.g. ordering of edges on vertices).</span>

<span class="sd">		:param destination: The destination vertex to reach.</span>
<span class="sd">		:returns:           A generator to iterate all vertices on the path found between this vertex and the destination vertex.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># Improvements: both-sided Dijkstra (search from start and destination to reduce discovered area.</span>

		<span class="c1"># Trivial case if start is destination</span>
		<span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">destination</span><span class="p">:</span>
			<span class="k">yield</span> <span class="bp">self</span>
			<span class="k">return</span>

		<span class="c1"># Local struct to create multiple-linked lists forming a paths from current node back to the starting point</span>
		<span class="c1"># (actually a tree). Each node holds the overall weight from start to current node and a reference to the vertex it</span>
		<span class="c1"># represents.</span>
		<span class="c1"># Hint: slotted classes are faster than &#39;@dataclasses.dataclass&#39;.</span>
		<span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ExtendedType</span><span class="p">,</span> <span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
			<span class="n">parent</span><span class="p">:</span> <span class="s1">&#39;Node&#39;</span>
			<span class="n">distance</span><span class="p">:</span> <span class="n">EdgeWeightType</span>
			<span class="n">ref</span><span class="p">:</span> <span class="n">Vertex</span>

			<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="s1">&#39;Node&#39;</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">ref</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>

			<span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">distance</span>

			<span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
				<span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Vertex: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">ID</span><span class="si">}</span><span class="s2">&quot;</span>

		<span class="n">visited</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="s1">&#39;Vertex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="n">startNode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
		<span class="n">priorityQueue</span> <span class="o">=</span> <span class="p">[</span><span class="n">startNode</span><span class="p">]</span>

		<span class="c1"># Add starting vertex and all its children to the processing list.</span>
		<span class="c1"># If a child is the destination, break immediately else go into &#39;else&#39; branch and use Dijkstra algorithm.</span>
		<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
			<span class="n">nextVertex</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">Destination</span>
			<span class="c1"># Child is destination, so construct the last node for path traversal and break from loop.</span>
			<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">is</span> <span class="n">destination</span><span class="p">:</span>
				<span class="n">destinationNode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">startNode</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">nextVertex</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="c1"># Ignore backward-edges and side-edges.</span>
			<span class="c1"># Here self-edges, because there is only the starting vertex in the list of visited edges.</span>
			<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
				<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
				<span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">priorityQueue</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="n">startNode</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">nextVertex</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># Process priority queue until destination is found or no further vertices are reachable.</span>
			<span class="k">while</span> <span class="n">priorityQueue</span><span class="p">:</span>
				<span class="n">node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">priorityQueue</span><span class="p">)</span>
				<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">:</span>
					<span class="n">nextVertex</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">Destination</span>
					<span class="c1"># Next reachable vertex is destination, so construct the last node for path traversal and break from loop.</span>
					<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">is</span> <span class="n">destination</span><span class="p">:</span>
						<span class="n">destinationNode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">distance</span> <span class="o">+</span> <span class="n">edge</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">nextVertex</span><span class="p">)</span>
						<span class="k">break</span>
					<span class="c1"># Ignore backward-edges and side-edges.</span>
					<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
						<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
						<span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">priorityQueue</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">distance</span> <span class="o">+</span> <span class="n">edge</span><span class="o">.</span><span class="n">_weight</span><span class="p">,</span> <span class="n">nextVertex</span><span class="p">))</span>
				<span class="c1"># Next 3 lines realize a double-break if break was called in inner loop, otherwise continue with outer loop.</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">continue</span>
				<span class="k">break</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># All reachable vertices have been processed, but destination was not among them.</span>
				<span class="k">raise</span> <span class="n">DestinationNotReachable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Destination is not reachable.&quot;</span><span class="p">)</span>

		<span class="c1"># Reverse order of linked-list from destinationNode to startNode</span>
		<span class="n">currentNode</span> <span class="o">=</span> <span class="n">destinationNode</span>
		<span class="n">previousNode</span> <span class="o">=</span> <span class="n">destinationNode</span><span class="o">.</span><span class="n">parent</span>
		<span class="n">currentNode</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">while</span> <span class="n">previousNode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">previousNode</span><span class="o">.</span><span class="n">parent</span>
			<span class="n">previousNode</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentNode</span>
			<span class="n">currentNode</span> <span class="o">=</span> <span class="n">previousNode</span>
			<span class="n">previousNode</span> <span class="o">=</span> <span class="n">node</span>

		<span class="c1"># Scan reversed linked-list and yield referenced vertices</span>
		<span class="k">yield</span> <span class="n">startNode</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">startNode</span><span class="o">.</span><span class="n">distance</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">startNode</span><span class="o">.</span><span class="n">parent</span>
		<span class="k">while</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">distance</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span></div>


		<span class="c1"># Other possible algorithms:</span>
		<span class="c1"># * Bellman-Ford</span>
		<span class="c1"># * Floyd-Warshall</span>

	<span class="c1"># def PathExistsTo(self, destination: &#39;Vertex&#39;):</span>
	<span class="c1"># 	raise NotImplementedError()</span>
	<span class="c1"># 	# DFS</span>
	<span class="c1"># 	# Union find</span>
	<span class="c1">#</span>
	<span class="c1"># def MaximumFlowTo(self, destination: &#39;Vertex&#39;):</span>
	<span class="c1"># 	raise NotImplementedError()</span>
	<span class="c1"># 	# Ford-Fulkerson algorithm</span>
	<span class="c1"># 	# Edmons-Karp algorithm</span>
	<span class="c1"># 	# Dinic&#39;s algorithm</span>

<div class="viewcode-block" id="Vertex.ConvertToTree">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.ConvertToTree">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">ConvertToTree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Converts all reachable vertices from this starting vertex to a tree of :class:`~pyTooling.Tree.Node` instances.</span>

<span class="sd">		The tree is traversed using depths-first-search.</span>

<span class="sd">		:returns:</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">visited</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">typing_Iterator</span><span class="p">[</span><span class="n">Edge</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

		<span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">nodeID</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>
		<span class="n">root</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

		<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">root</span><span class="p">,</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)))</span>

		<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">edge</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">nextVertex</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_destination</span>
				<span class="k">if</span> <span class="n">nextVertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
					<span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">nextVertex</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">nextVertex</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
					<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nextVertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
						<span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="nb">iter</span><span class="p">(</span><span class="n">nextVertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="n">NotATreeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The directed subgraph is not a tree.&quot;</span><span class="p">)</span>
					<span class="c1"># TODO: compute cycle:</span>
					<span class="c1">#       a) branch 1 is described in stack</span>
					<span class="c1">#       b) branch 2 can be found by walking from joint to root in the tree</span>
			<span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
				<span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">return</span> <span class="n">root</span></div>


<div class="viewcode-block" id="Vertex.__repr__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.__repr__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a detailed string representation of the vertex.</span>

<span class="sd">		:returns: The detailed string representation of the vertex.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">vertexID</span> <span class="o">=</span> <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;: &quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">vertexID</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sep</span><span class="si">}</span><span class="s2">vertexID=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
			<span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;; &quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">value</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sep</span><span class="si">}</span><span class="s2">value=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="si">}</span><span class="s2">&#39;&quot;</span>

		<span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;vertex</span><span class="si">{</span><span class="n">vertexID</span><span class="si">}{</span><span class="n">value</span><span class="si">}</span><span class="s2">&gt;&quot;</span></div>


<div class="viewcode-block" id="Vertex.__str__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Vertex.__str__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return a string representation of the vertex.</span>

<span class="sd">		Order of resolution:</span>

<span class="sd">		1. If :attr:`_value` is not None, return the string representation of :attr:`_value`.</span>
<span class="sd">		2. If :attr:`_id` is not None, return the string representation of :attr:`_id`.</span>
<span class="sd">		3. Else, return :meth:`__repr__`.</span>

<span class="sd">		:returns: The resolved string representation of the vertex.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>
		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="BaseEdge">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseEdge">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseEdge</span><span class="p">(</span>
	<span class="n">BaseWithIDValueAndWeight</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">]</span>
<span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	An **edge** can have a unique ID, a value, a weight and attached meta information as key-value-pairs. All edges are</span>
<span class="sd">	directed.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">_source</span><span class="p">:</span>      <span class="n">Vertex</span>
	<span class="n">_destination</span><span class="p">:</span> <span class="n">Vertex</span>

<div class="viewcode-block" id="BaseEdge.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseEdge.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">source</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span>
		<span class="n">destination</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span>
		<span class="n">edgeID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">value</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">weight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::BaseEdge::init Needs documentation.</span>

<span class="sd">		:param source:        The source of the new edge.</span>
<span class="sd">		:param destination:   The destination of the new edge.</span>
<span class="sd">		:param edgeID:        The optional unique ID for the new edge.</span>
<span class="sd">		:param value:         The optional value for the new edge.</span>
<span class="sd">		:param weight:        The optional weight for the new edge.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">edgeID</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="n">source</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_destination</span> <span class="o">=</span> <span class="n">destination</span>

		<span class="n">component</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">_component</span>
		<span class="k">if</span> <span class="n">component</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">destination</span><span class="o">.</span><span class="n">_component</span><span class="p">:</span>
			<span class="c1"># TODO: should it be divided into with/without ID?</span>
			<span class="n">oldComponent</span> <span class="o">=</span> <span class="n">destination</span><span class="o">.</span><span class="n">_component</span>
			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">oldComponent</span><span class="o">.</span><span class="n">_vertices</span><span class="p">:</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_component</span> <span class="o">=</span> <span class="n">component</span>
				<span class="n">component</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
			<span class="n">component</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_components</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">oldComponent</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">oldComponent</span></div>


	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Source</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vertex</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get the source (:attr:`_source`) of an edge.</span>

<span class="sd">		:returns: The source of an edge.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Destination</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vertex</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to get the destination (:attr:`_destination`) of an edge.</span>

<span class="sd">		:returns: The destination of an edge.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_destination</span>

<div class="viewcode-block" id="BaseEdge.Reverse">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseEdge.Reverse">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">Reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Reverse the direction of this edge.&quot;&quot;&quot;</span>
		<span class="n">swap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_destination</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_destination</span> <span class="o">=</span> <span class="n">swap</span></div>
</div>



<div class="viewcode-block" id="Edge">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Edge">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Edge</span><span class="p">(</span>
	<span class="n">BaseEdge</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">]</span>
<span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	An **edge** can have a unique ID, a value, a weight and attached meta information as key-value-pairs. All edges are</span>
<span class="sd">	directed.</span>
<span class="sd">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Edge.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Edge.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">source</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span>
		<span class="n">destination</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span>
		<span class="n">edgeID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">value</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeValueType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">weight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">EdgeWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Edge::init Needs documentation.</span>

<span class="sd">		:param source:        The source of the new edge.</span>
<span class="sd">		:param destination:   The destination of the new edge.</span>
<span class="sd">		:param edgeID:        The optional unique ID for the new edge.</span>
<span class="sd">		:param value:         The optional value for the new edge.</span>
<span class="sd">		:param weight:        The optional weight for the new edge.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;source&#39; is not of type &#39;Vertex&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;destination&#39; is not of type &#39;Vertex&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>
		<span class="k">if</span> <span class="n">edgeID</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edgeID</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;edgeID&#39; is not of type &#39;EdgeIDType&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">edgeID</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>
		<span class="c1"># if value is not None and  not isinstance(value, Vertex):</span>
		<span class="c1"># 	raise TypeError(&quot;Parameter &#39;value&#39; is not of type &#39;EdgeValueType&#39;.&quot;)</span>
		<span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;weight&#39; is not of type &#39;EdgeWeightType&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>
		<span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">_graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">destination</span><span class="o">.</span><span class="n">_graph</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">NotInSameGraph</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Source vertex and destination vertex are not in same graph.&quot;</span><span class="p">)</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">edgeID</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span></div>


	<span class="k">def</span><span class="w"> </span><span class="nf">Delete</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
		<span class="c1"># Remove from Source and Destination</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

		<span class="c1"># Remove from Graph and Subgraph</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">]</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_subgraph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_subgraph</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>

	<span class="k">def</span><span class="w"> </span><span class="nf">_Delete</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">Delete</span><span class="p">()</span>

<div class="viewcode-block" id="Edge.Reverse">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Edge.Reverse">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">Reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Reverse the direction of this edge.&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">Reverse</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="Link">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Link">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Link</span><span class="p">(</span>
	<span class="n">BaseEdge</span><span class="p">[</span><span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span><span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">]</span>
<span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	A **link** can have a unique ID, a value, a weight and attached meta information as key-value-pairs. All links are</span>
<span class="sd">	directed.</span>
<span class="sd">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Link.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Link.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">source</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span>
		<span class="n">destination</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span>
		<span class="n">linkID</span><span class="p">:</span> <span class="n">LinkIDType</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">value</span><span class="p">:</span> <span class="n">LinkValueType</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">weight</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">LinkWeightType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Edge::init Needs documentation.</span>

<span class="sd">		:param source:        The source of the new link.</span>
<span class="sd">		:param destination:   The destination of the new link.</span>
<span class="sd">		:param linkID:        The optional unique ID for the new link.</span>
<span class="sd">		:param value:         The optional value for the new v.</span>
<span class="sd">		:param weight:        The optional weight for the new link.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;source&#39; is not of type &#39;Vertex&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;destination&#39; is not of type &#39;Vertex&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>
		<span class="k">if</span> <span class="n">linkID</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkID</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;linkID&#39; is not of type &#39;LinkIDType&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">linkID</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>
		<span class="c1"># if value is not None and  not isinstance(value, Vertex):</span>
		<span class="c1"># 	raise TypeError(&quot;Parameter &#39;value&#39; is not of type &#39;EdgeValueType&#39;.&quot;)</span>
		<span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;weight&#39; is not of type &#39;EdgeWeightType&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>
		<span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">_graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">destination</span><span class="o">.</span><span class="n">_graph</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">NotInSameGraph</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Source vertex and destination vertex are not in same graph.&quot;</span><span class="p">)</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">linkID</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span></div>


	<span class="k">def</span><span class="w"> </span><span class="nf">Delete</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">]</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>
		<span class="k">assert</span> <span class="n">getrefcount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

	<span class="k">def</span><span class="w"> </span><span class="nf">_Delete</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">Delete</span><span class="p">()</span>

<div class="viewcode-block" id="Link.Reverse">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Link.Reverse">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">Reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Reverse the direction of this link.&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">Reverse</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="BaseGraph">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseGraph</span><span class="p">(</span>
	<span class="n">BaseWithName</span><span class="p">[</span><span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span>
		<span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">]</span>
<span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	.. todo:: GRAPH::BaseGraph Needs documentation.</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="n">_verticesWithID</span><span class="p">:</span>    <span class="n">Dict</span><span class="p">[</span><span class="n">VertexIDType</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">[</span><span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span> <span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span> <span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span> <span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">]]</span>
	<span class="n">_verticesWithoutID</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Vertex</span><span class="p">[</span><span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span> <span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span> <span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span> <span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">]]</span>
	<span class="n">_edgesWithID</span><span class="p">:</span>       <span class="n">Dict</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">Edge</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">]]</span>
	<span class="n">_edgesWithoutID</span><span class="p">:</span>    <span class="n">List</span><span class="p">[</span><span class="n">Edge</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">]]</span>
	<span class="n">_linksWithID</span><span class="p">:</span>       <span class="n">Dict</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">Link</span><span class="p">[</span><span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">]]</span>
	<span class="n">_linksWithoutID</span><span class="p">:</span>    <span class="n">List</span><span class="p">[</span><span class="n">Link</span><span class="p">[</span><span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">]]</span>

<div class="viewcode-block" id="BaseGraph.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">name</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="c1">#, vertices: Nullable[Iterable[Vertex]] = None) -&gt; None:</span>
	<span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::BaseGraph::init Needs documentation.</span>

<span class="sd">		:param name:          The optional name of the graph.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span> <span class="o">=</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="BaseGraph.__del__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.__del__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::BaseGraph::del Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span>
		<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
			<span class="k">pass</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span></div>


	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">VertexCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Read-only property to access the number of vertices in this graph.</span>

<span class="sd">		:returns: The number of vertices in this graph.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">EdgeCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Read-only property to access the number of edges in this graph.</span>

<span class="sd">		:returns: The number of edges in this graph.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">LinkCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Read-only property to access the number of links in this graph.</span>

<span class="sd">		:returns: The number of links in this graph.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">)</span>

<div class="viewcode-block" id="BaseGraph.IterateVertices">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.IterateVertices">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateVertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Vertex</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Vertex</span><span class="p">[</span><span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span> <span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span> <span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span> <span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected vertices of a graph.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip vertices in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any vertex and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all vertices.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span>
			<span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">vertex</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">vertex</span></div>


<div class="viewcode-block" id="BaseGraph.IterateRoots">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.IterateRoots">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateRoots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Vertex</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Vertex</span><span class="p">[</span><span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span> <span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span> <span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span> <span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected roots (vertices without inbound edges / without predecessors) of a graph.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip vertices in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any vertex and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all vertices without inbound edges.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`IterateLeafs` |br|</span>
<span class="sd">		      |rarr| Iterate leafs of a graph.</span>
<span class="sd">		   :meth:`Vertex.IsRoot &lt;pyTooling.Graph.Vertex.IsRoot&gt;` |br|</span>
<span class="sd">		      |rarr| Check if a vertex is a root vertex in the graph.</span>
<span class="sd">		   :meth:`Vertex.IsLeaf &lt;pyTooling.Graph.Vertex.IsLeaf&gt;` |br|</span>
<span class="sd">		      |rarr| Check if a vertex is a leaf vertex in the graph.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">yield</span> <span class="n">vertex</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">yield</span> <span class="n">vertex</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">vertex</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">vertex</span></div>


<div class="viewcode-block" id="BaseGraph.IterateLeafs">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.IterateLeafs">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateLeafs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Vertex</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Vertex</span><span class="p">[</span><span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span> <span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span> <span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span> <span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected leafs (vertices without outbound edges / without successors) of a graph.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip vertices in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any vertex and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all vertices without outbound edges.</span>

<span class="sd">		.. seealso::</span>

<span class="sd">		   :meth:`IterateRoots` |br|</span>
<span class="sd">		      |rarr| Iterate roots of a graph.</span>
<span class="sd">		   :meth:`Vertex.IsRoot &lt;pyTooling.Graph.Vertex.IsRoot&gt;` |br|</span>
<span class="sd">		      |rarr| Check if a vertex is a root vertex in the graph.</span>
<span class="sd">		   :meth:`Vertex.IsLeaf &lt;pyTooling.Graph.Vertex.IsLeaf&gt;` |br|</span>
<span class="sd">		      |rarr| Check if a vertex is a leaf vertex in the graph.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">yield</span> <span class="n">vertex</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">yield</span> <span class="n">vertex</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">vertex</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">vertex</span></div>


	<span class="c1"># def IterateBFS(self, predicate: Nullable[Callable[[Vertex], bool]] = None) -&gt; Generator[Vertex[GraphDictKeyType, GraphDictValueType, VertexIDType, VertexWeightType, VertexValueType, VertexDictKeyType, VertexDictValueType, EdgeIDType, EdgeWeightType, EdgeValueType, EdgeDictKeyType, EdgeDictValueType, LinkIDType, LinkWeightType, LinkValueType, LinkDictKeyType, LinkDictValueType], None, None]:</span>
	<span class="c1"># 	raise NotImplementedError()</span>
	<span class="c1">#</span>
	<span class="c1"># def IterateDFS(self, predicate: Nullable[Callable[[Vertex], bool]] = None) -&gt; Generator[Vertex[GraphDictKeyType, GraphDictValueType, VertexIDType, VertexWeightType, VertexValueType, VertexDictKeyType, VertexDictValueType, EdgeIDType, EdgeWeightType, EdgeValueType, EdgeDictKeyType, EdgeDictValueType, LinkIDType, LinkWeightType, LinkValueType, LinkDictKeyType, LinkDictValueType], None, None]:</span>
	<span class="c1"># 	raise NotImplementedError()</span>

<div class="viewcode-block" id="BaseGraph.IterateTopologically">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.IterateTopologically">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateTopologically</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Vertex</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Vertex</span><span class="p">[</span><span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span> <span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span> <span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span> <span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected vertices in topological order.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip vertices in the generator.</span>

<span class="sd">		:param predicate:   Filter function accepting any vertex and returning a boolean.</span>
<span class="sd">		:returns:           A generator to iterate all vertices in topological order.</span>
<span class="sd">		:except CycleError: Raised if graph is cyclic, thus topological sorting isn&#39;t possible.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">outboundEdgeCounts</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">leafVertices</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">leafVertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">outboundEdgeCounts</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>

		<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">leafVertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">outboundEdgeCounts</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="n">leafVertices</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">CycleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Graph has no leafs. Thus, no topological sorting exists.&quot;</span><span class="p">)</span>

		<span class="n">overallCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outboundEdgeCounts</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">leafVertices</span><span class="p">)</span>

		<span class="k">def</span><span class="w"> </span><span class="nf">removeVertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">):</span>
			<span class="k">nonlocal</span> <span class="n">overallCount</span>
			<span class="n">overallCount</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="k">for</span> <span class="n">inboundEdge</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">:</span>
				<span class="n">sourceVertex</span> <span class="o">=</span> <span class="n">inboundEdge</span><span class="o">.</span><span class="n">Source</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">outboundEdgeCounts</span><span class="p">[</span><span class="n">sourceVertex</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
				<span class="n">outboundEdgeCounts</span><span class="p">[</span><span class="n">sourceVertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
				<span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">leafVertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sourceVertex</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">leafVertices</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">vertex</span>

				<span class="n">removeVertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">leafVertices</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">vertex</span>

				<span class="n">removeVertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">overallCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="k">elif</span> <span class="n">overallCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">CycleError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Graph has remaining vertices. Thus, the graph has at least one cycle.&quot;</span><span class="p">)</span>

		<span class="k">raise</span> <span class="n">InternalError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Graph data structure is corrupted.&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span></div>


<div class="viewcode-block" id="BaseGraph.IterateEdges">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.IterateEdges">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Edge</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Edge</span><span class="p">[</span><span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected edges of a graph.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip edges in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any edge and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all edges.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span>
			<span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">edge</span>

			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">edge</span></div>


<div class="viewcode-block" id="BaseGraph.IterateLinks">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.IterateLinks">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">IterateLinks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Link</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Link</span><span class="p">[</span><span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate all or selected links of a graph.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip links in the generator.</span>

<span class="sd">		:param predicate: Filter function accepting any link and returning a boolean.</span>
<span class="sd">		:returns:         A generator to iterate all links.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span>
			<span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">link</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">link</span>

			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">link</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">link</span></div>


<div class="viewcode-block" id="BaseGraph.ReverseEdges">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.ReverseEdges">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">ReverseEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Edge</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Reverse all or selected edges of a graph.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip edges.</span>

<span class="sd">		:param predicate: Filter function accepting any edge and returning a boolean.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="p">:</span>
				<span class="n">swap</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_source</span>
				<span class="n">edge</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_destination</span>
				<span class="n">edge</span><span class="o">.</span><span class="n">_destination</span> <span class="o">=</span> <span class="n">swap</span>

			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="n">swap</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_source</span>
				<span class="n">edge</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_destination</span>
				<span class="n">edge</span><span class="o">.</span><span class="n">_destination</span> <span class="o">=</span> <span class="n">swap</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="n">swap</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span> <span class="o">=</span> <span class="n">swap</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="n">swap</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span> <span class="o">=</span> <span class="n">swap</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
					<span class="n">edge</span><span class="o">.</span><span class="n">Reverse</span><span class="p">()</span>

			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
					<span class="n">edge</span><span class="o">.</span><span class="n">Reverse</span><span class="p">()</span></div>


<div class="viewcode-block" id="BaseGraph.ReverseLinks">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.ReverseLinks">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">ReverseLinks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Link</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Reverse all or selected links of a graph.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip links.</span>

<span class="sd">		:param predicate: Filter function accepting any link and returning a boolean.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="p">:</span>
				<span class="n">swap</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">_source</span>
				<span class="n">link</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">_destination</span>
				<span class="n">link</span><span class="o">.</span><span class="n">_destination</span> <span class="o">=</span> <span class="n">swap</span>

			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="n">swap</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">_source</span>
				<span class="n">link</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">_destination</span>
				<span class="n">link</span><span class="o">.</span><span class="n">_destination</span> <span class="o">=</span> <span class="n">swap</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="n">swap</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_inboundLinks</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundLinks</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_outboundLinks</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundLinks</span> <span class="o">=</span> <span class="n">swap</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="n">swap</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_inboundLinks</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundLinks</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_outboundLinks</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundLinks</span> <span class="o">=</span> <span class="n">swap</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">link</span><span class="p">):</span>
					<span class="n">link</span><span class="o">.</span><span class="n">Reverse</span><span class="p">()</span>

			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">link</span><span class="p">):</span>
					<span class="n">link</span><span class="o">.</span><span class="n">Reverse</span><span class="p">()</span></div>


<div class="viewcode-block" id="BaseGraph.RemoveEdges">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.RemoveEdges">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">RemoveEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Edge</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Remove all or selected edges of a graph.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip edges.</span>

<span class="sd">		:param predicate: Filter function accepting any edge and returning a boolean.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="p">:</span>
				<span class="n">edge</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>

			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="n">edge</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span> <span class="o">=</span> <span class="p">{}</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span> <span class="o">=</span> <span class="p">[]</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="n">delEdges</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">edge</span><span class="p">)]</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">delEdges</span><span class="p">:</span>
				<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithID</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">_id</span><span class="p">]</span>

				<span class="n">edge</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
				<span class="n">edge</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
				<span class="n">edge</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>

			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_edgesWithoutID</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

					<span class="n">edge</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
					<span class="n">edge</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
					<span class="n">edge</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span></div>


<div class="viewcode-block" id="BaseGraph.RemoveLinks">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.RemoveLinks">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">RemoveLinks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Link</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Remove all or selected links of a graph.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip links.</span>

<span class="sd">		:param predicate: Filter function accepting any link and returning a boolean.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="p">:</span>
				<span class="n">link</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>

			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="n">link</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span> <span class="o">=</span> <span class="p">{}</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundLinks</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundLinks</span> <span class="o">=</span> <span class="p">[]</span>

			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_inboundLinks</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">vertex</span><span class="o">.</span><span class="n">_outboundLinks</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="n">delLinks</span> <span class="o">=</span> <span class="p">[</span><span class="n">link</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">link</span><span class="p">)]</span>
			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">delLinks</span><span class="p">:</span>
				<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithID</span><span class="p">[</span><span class="n">link</span><span class="o">.</span><span class="n">_id</span><span class="p">]</span>

				<span class="n">link</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
				<span class="n">link</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
				<span class="n">link</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span>

			<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">link</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_linksWithoutID</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>

					<span class="n">link</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">_outboundLinks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
					<span class="n">link</span><span class="o">.</span><span class="n">_destination</span><span class="o">.</span><span class="n">_inboundLinks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
					<span class="n">link</span><span class="o">.</span><span class="n">_Delete</span><span class="p">()</span></div>


<div class="viewcode-block" id="BaseGraph.HasCycle">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.BaseGraph.HasCycle">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">HasCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::BaseGraph::HasCycle Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># IsAcyclic ?</span>

		<span class="c1"># Handle trivial case if graph is empty</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">False</span>

		<span class="n">outboundEdgeCounts</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">leafVertices</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">leafVertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">outboundEdgeCounts</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>

		<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_outboundEdges</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">leafVertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">outboundEdgeCounts</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>

		<span class="c1"># If there are no leafs, then each vertex has at least one inbound and one outbound edges. Thus, there is a cycle.</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">leafVertices</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">True</span>

		<span class="n">overallCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outboundEdgeCounts</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">leafVertices</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">leafVertices</span><span class="p">:</span>
			<span class="n">overallCount</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="k">for</span> <span class="n">inboundEdge</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_inboundEdges</span><span class="p">:</span>
				<span class="n">sourceVertex</span> <span class="o">=</span> <span class="n">inboundEdge</span><span class="o">.</span><span class="n">Source</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">outboundEdgeCounts</span><span class="p">[</span><span class="n">sourceVertex</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
				<span class="n">outboundEdgeCounts</span><span class="p">[</span><span class="n">sourceVertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
				<span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">leafVertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sourceVertex</span><span class="p">)</span>

		<span class="c1"># If all vertices were processed, no cycle exists.</span>
		<span class="k">if</span> <span class="n">overallCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">False</span>
		<span class="c1"># If there are remaining vertices, then a cycle exists.</span>
		<span class="k">elif</span> <span class="n">overallCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">True</span>

		<span class="k">raise</span> <span class="n">InternalError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Graph data structure is corrupted.&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span></div>
</div>



<div class="viewcode-block" id="Subgraph">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Subgraph">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Subgraph</span><span class="p">(</span>
	<span class="n">BaseGraph</span><span class="p">[</span>
		<span class="n">SubgraphDictKeyType</span><span class="p">,</span> <span class="n">SubgraphDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span>
		<span class="n">SubgraphDictKeyType</span><span class="p">,</span> <span class="n">SubgraphDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">]</span>
<span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	.. todo:: GRAPH::Subgraph Needs documentation.</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="n">_graph</span><span class="p">:</span>    <span class="s1">&#39;Graph&#39;</span>

<div class="viewcode-block" id="Subgraph.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Subgraph.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">graph</span><span class="p">:</span> <span class="s1">&#39;Graph&#39;</span><span class="p">,</span>
		<span class="n">name</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="c1"># vertices: Nullable[Iterable[Vertex]] = None,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Subgraph::init Needs documentation.</span>

<span class="sd">		:param graph:         The reference to the graph.</span>
<span class="sd">		:param name:          The optional name of the new sub-graph.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;graph&#39; is None.&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">):</span>
			<span class="n">ex</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;graph&#39; is not of type &#39;Graph&#39;.&quot;</span><span class="p">)</span>
			<span class="n">ex</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got type &#39;</span><span class="si">{</span><span class="n">getFullyQualifiedName</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
			<span class="k">raise</span> <span class="n">ex</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

		<span class="n">graph</span><span class="o">.</span><span class="n">_subgraphs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span></div>


<div class="viewcode-block" id="Subgraph.__del__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Subgraph.__del__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Subgraph::del Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span></div>


	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Graph&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Read-only property to access the graph, this subgraph is associated to (:attr:`_graph`).</span>

<span class="sd">		:returns: The graph this subgraph is associated to.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span>

<div class="viewcode-block" id="Subgraph.__str__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Subgraph.__str__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Subgraph::str Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;Unnamed subgraph&quot;</span></div>
</div>



<div class="viewcode-block" id="View">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.View">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">View</span><span class="p">(</span>
	<span class="n">BaseWithVertices</span><span class="p">[</span>
		<span class="n">ViewDictKeyType</span><span class="p">,</span> <span class="n">ViewDictValueType</span><span class="p">,</span>
		<span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span>
		<span class="n">ViewDictKeyType</span><span class="p">,</span> <span class="n">ViewDictValueType</span><span class="p">,</span>
		<span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">]</span>
<span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	.. todo:: GRAPH::View Needs documentation.</span>

<span class="sd">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="View.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.View.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">graph</span><span class="p">:</span> <span class="s1">&#39;Graph&#39;</span><span class="p">,</span>
		<span class="n">name</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">vertices</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::View::init Needs documentation.</span>

<span class="sd">		:param graph:         The reference to the graph.</span>
<span class="sd">		:param name:          The optional name of the new view.</span>
<span class="sd">		:param vertices:      The optional list of vertices in the new view.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

		<span class="n">graph</span><span class="o">.</span><span class="n">_views</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="View.__del__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.View.__del__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::View::del Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span></div>


<div class="viewcode-block" id="View.__str__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.View.__str__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::View::str Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;Unnamed view&quot;</span></div>
</div>



<div class="viewcode-block" id="Component">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Component">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Component</span><span class="p">(</span>
	<span class="n">BaseWithVertices</span><span class="p">[</span>
		<span class="n">ComponentDictKeyType</span><span class="p">,</span> <span class="n">ComponentDictValueType</span><span class="p">,</span>
		<span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span>
		<span class="n">ComponentDictKeyType</span><span class="p">,</span> <span class="n">ComponentDictValueType</span><span class="p">,</span>
		<span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">]</span>
<span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	.. todo:: GRAPH::Component Needs documentation.</span>

<span class="sd">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Component.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Component.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">graph</span><span class="p">:</span> <span class="s1">&#39;Graph&#39;</span><span class="p">,</span>
		<span class="n">name</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">vertices</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Component::init Needs documentation.</span>

<span class="sd">		:param graph:         The reference to the graph.</span>
<span class="sd">		:param name:          The optional name of the new component.</span>
<span class="sd">		:param vertices:      The optional list of vertices in the new component.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

		<span class="n">graph</span><span class="o">.</span><span class="n">_components</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Component.__del__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Component.__del__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Component::del Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span></div>


<div class="viewcode-block" id="Component.__str__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Component.__str__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Component::str Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;Unnamed component&quot;</span></div>
</div>



<div class="viewcode-block" id="Graph">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph">[docs]</a>
<span class="nd">@export</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Graph</span><span class="p">(</span>
	<span class="n">BaseGraph</span><span class="p">[</span>
		<span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">],</span>
	<span class="n">Generic</span><span class="p">[</span>
		<span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span>
		<span class="n">ComponentDictKeyType</span><span class="p">,</span> <span class="n">ComponentDictValueType</span><span class="p">,</span>
		<span class="n">SubgraphDictKeyType</span><span class="p">,</span> <span class="n">SubgraphDictValueType</span><span class="p">,</span>
		<span class="n">ViewDictKeyType</span><span class="p">,</span> <span class="n">ViewDictValueType</span><span class="p">,</span>
		<span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span>
		<span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span>
		<span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span>
	<span class="p">]</span>
<span class="p">):</span>
<span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	A **graph** data structure is represented by an instance of :class:`~pyTooling.Graph.Graph` holding references to</span>
<span class="sd">	all nodes. Nodes are instances of :class:`~pyTooling.Graph.Vertex` classes and directed links between nodes are</span>
<span class="sd">	made of :class:`~pyTooling.Graph.Edge` instances. A graph can have attached meta information as key-value-pairs.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">_subgraphs</span><span class="p">:</span>         <span class="n">Set</span><span class="p">[</span><span class="n">Subgraph</span><span class="p">[</span><span class="n">SubgraphDictKeyType</span><span class="p">,</span> <span class="n">SubgraphDictValueType</span><span class="p">,</span> <span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span> <span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span> <span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">]]</span>
	<span class="n">_views</span><span class="p">:</span>             <span class="n">Set</span><span class="p">[</span><span class="n">View</span><span class="p">[</span><span class="n">ViewDictKeyType</span><span class="p">,</span> <span class="n">ViewDictValueType</span><span class="p">,</span> <span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span> <span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span> <span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span> <span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">]]</span>
	<span class="n">_components</span><span class="p">:</span>        <span class="n">Set</span><span class="p">[</span><span class="n">Component</span><span class="p">[</span><span class="n">ComponentDictKeyType</span><span class="p">,</span> <span class="n">ComponentDictValueType</span><span class="p">,</span> <span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span> <span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span> <span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span> <span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">]]</span>

<div class="viewcode-block" id="Graph.__init__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph.__init__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">name</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
		<span class="n">keyValuePairs</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">DictKeyType</span><span class="p">,</span> <span class="n">DictValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Graph::init Needs documentation.</span>

<span class="sd">		:param name:          The optional name of the new graph.</span>
<span class="sd">		:param keyValuePairs: The optional mapping (dictionary) of key-value-pairs.#</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">keyValuePairs</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_subgraphs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_views</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_components</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span></div>


<div class="viewcode-block" id="Graph.__del__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph.__del__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Graph::del Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraphs</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span>
			<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_components</span>
		<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
			<span class="k">pass</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__del__</span><span class="p">()</span></div>


	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Subgraph</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Read-only property to access the subgraphs in this graph (:attr:`_subgraphs`).</span>

<span class="sd">		:returns: The set of subgraphs in this graph.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraphs</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Views</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">View</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Read-only property to access the views in this graph (:attr:`_views`).</span>

<span class="sd">		:returns: The set of views in this graph.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">Components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Component</span><span class="p">]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Read-only property to access the components in this graph (:attr:`_components`).</span>

<span class="sd">		:returns: The set of components in this graph.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_components</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">SubgraphCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Read-only property to access the number of subgraphs in this graph.</span>

<span class="sd">		:returns: The number of subgraphs in this graph.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subgraphs</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">ViewCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Read-only property to access the number of views in this graph.</span>

<span class="sd">		:returns: The number of views in this graph.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">)</span>

	<span class="nd">@readonly</span>
	<span class="k">def</span><span class="w"> </span><span class="nf">ComponentCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;Read-only property to access the number of components in this graph.</span>

<span class="sd">		:returns: The number of components in this graph.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_components</span><span class="p">)</span>

<div class="viewcode-block" id="Graph.__iter__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph.__iter__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing_Iterator</span><span class="p">[</span><span class="n">Vertex</span><span class="p">[</span><span class="n">GraphDictKeyType</span><span class="p">,</span> <span class="n">GraphDictValueType</span><span class="p">,</span> <span class="n">VertexIDType</span><span class="p">,</span> <span class="n">VertexWeightType</span><span class="p">,</span> <span class="n">VertexValueType</span><span class="p">,</span> <span class="n">VertexDictKeyType</span><span class="p">,</span> <span class="n">VertexDictValueType</span><span class="p">,</span> <span class="n">EdgeIDType</span><span class="p">,</span> <span class="n">EdgeWeightType</span><span class="p">,</span> <span class="n">EdgeValueType</span><span class="p">,</span> <span class="n">EdgeDictKeyType</span><span class="p">,</span> <span class="n">EdgeDictValueType</span><span class="p">,</span> <span class="n">LinkIDType</span><span class="p">,</span> <span class="n">LinkWeightType</span><span class="p">,</span> <span class="n">LinkValueType</span><span class="p">,</span> <span class="n">LinkDictKeyType</span><span class="p">,</span> <span class="n">LinkDictValueType</span><span class="p">]]:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Graph::iter Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">def</span><span class="w"> </span><span class="nf">gen</span><span class="p">():</span>
			<span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span>
			<span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span>
		<span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span></div>


<div class="viewcode-block" id="Graph.HasVertexByID">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph.HasVertexByID">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">HasVertexByID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexIDType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Graph::HasVertexByID Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">vertexID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">vertexID</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span></div>


<div class="viewcode-block" id="Graph.HasVertexByValue">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph.HasVertexByValue">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">HasVertexByValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Graph::HasVertexByValue Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">_value</span> <span class="o">==</span> <span class="n">value</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span></div>


<div class="viewcode-block" id="Graph.GetVertexByID">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph.GetVertexByID">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">GetVertexByID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexID</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexIDType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Vertex</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Graph::GetVertexByID Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">vertexID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found no vertex with ID `None`.&quot;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found multiple vertices with ID `None`.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="p">[</span><span class="n">vertexID</span><span class="p">]</span></div>


<div class="viewcode-block" id="Graph.GetVertexByValue">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph.GetVertexByValue">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">GetVertexByValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">VertexValueType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Vertex</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Graph::GetVertexByValue Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># FIXME: optimize: iterate only until first item is found and check for a second to produce error</span>
		<span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertex</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_value</span> <span class="o">==</span> <span class="n">value</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found no vertex with Value == `</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found multiple vertices with Value == `</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span></div>


	<span class="k">def</span><span class="w"> </span><span class="nf">CopyGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Graph&#39;</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="Graph.CopyVertices">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph.CopyVertices">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="nf">CopyVertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Nullable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Vertex</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">copyGraphDict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">copyVertexDict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Graph&#39;</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Create a new graph and copy all or selected vertices of the original graph.</span>

<span class="sd">		If parameter ``predicate`` is not None, the given filter function is used to skip vertices.</span>

<span class="sd">		:param predicate:      Filter function accepting any vertex and returning a boolean.</span>
<span class="sd">		:param copyGraphDict:  If ``True``, copy all graph attached attributes into the new graph.</span>
<span class="sd">		:param copyVertexDict: If ``True``, copy all vertex attached attributes into the new vertices.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">copyGraphDict</span><span class="p">:</span>
			<span class="n">graph</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

		<span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="n">v</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">copyVertexDict</span><span class="p">:</span>
					<span class="n">v</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

			<span class="k">for</span> <span class="n">vertexID</span><span class="p">,</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="n">v</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="n">vertexID</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">copyVertexDict</span><span class="p">:</span>
					<span class="n">v</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithoutID</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
					<span class="n">v</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">copyVertexDict</span><span class="p">:</span>
						<span class="n">v</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

			<span class="k">for</span> <span class="n">vertexID</span><span class="p">,</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verticesWithID</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
					<span class="n">v</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="n">vertexID</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">copyVertexDict</span><span class="p">:</span>
						<span class="n">v</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

		<span class="k">return</span> <span class="n">graph</span></div>


		<span class="c1"># class Iterator():</span>
		<span class="c1"># 	visited = [False for _ in range(self.__len__())]</span>

	<span class="c1"># def CheckForNegativeCycles(self):</span>
	<span class="c1"># 	raise NotImplementedError()</span>
	<span class="c1"># 	# Bellman-Ford</span>
	<span class="c1"># 	# Floyd-Warshall</span>
	<span class="c1">#</span>
	<span class="c1"># def IsStronglyConnected(self):</span>
	<span class="c1"># 	raise NotImplementedError()</span>
	<span class="c1">#</span>
	<span class="c1"># def GetStronglyConnectedComponents(self):</span>
	<span class="c1"># 	raise NotImplementedError()</span>
	<span class="c1"># 	# Tarjan&#39;s and Kosaraju&#39;s algorithm</span>
	<span class="c1">#</span>
	<span class="c1"># def TravelingSalesmanProblem(self):</span>
	<span class="c1"># 	raise NotImplementedError()</span>
	<span class="c1"># 	# Held-Karp</span>
	<span class="c1"># 	# branch and bound</span>
	<span class="c1">#</span>
	<span class="c1"># def GetBridges(self):</span>
	<span class="c1"># 	raise NotImplementedError()</span>
	<span class="c1">#</span>
	<span class="c1"># def GetArticulationPoints(self):</span>
	<span class="c1"># 	raise NotImplementedError()</span>
	<span class="c1">#</span>
	<span class="c1"># def MinimumSpanningTree(self):</span>
	<span class="c1"># 	raise NotImplementedError()</span>
	<span class="c1"># 	# Kruskal</span>
	<span class="c1"># 	# Prim&#39;s algorithm</span>
	<span class="c1"># 	# Buruvka&#39;s algorithm</span>

<div class="viewcode-block" id="Graph.__repr__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph.__repr__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Graph::repr Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">statistics</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;, vertices: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">VertexCount</span><span class="si">}</span><span class="s2">, edges: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">EdgeCount</span><span class="si">}</span><span class="s2">&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;graph: unnamed graph</span><span class="si">{</span><span class="n">statistics</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;graph: &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2">&#39;</span><span class="si">{</span><span class="n">statistics</span><span class="si">}</span><span class="s2">&gt;&quot;</span></div>


<div class="viewcode-block" id="Graph.__str__">
<a class="viewcode-back" href="../../pyTooling/pyTooling.Graph.html#pyTooling.Graph.Graph.__str__">[docs]</a>
	<span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. todo:: GRAPH::Graph::str Needs documentation.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Graph: unnamed graph&quot;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Graph: &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2025, Patrick Lehmann.
      <span class="lastupdated">Last updated on 21.11.2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>